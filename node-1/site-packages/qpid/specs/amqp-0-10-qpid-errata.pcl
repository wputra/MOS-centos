(lp1
(S'ExecutionSync'
(cqpid.ops
Command
p2
t(dp3
S'CODE'
p4
I769
sS'NAME'
p5
S'execution_sync'
p6
sS'FIELDS'
p7
(lp8
sS'ARGS'
p9
(lp10
(iqpid.ops
Field
p11
(dp12
S'default'
p13
I0
sS'type'
p14
S'uint16'
p15
sS'name'
p16
S'channel'
p17
sba(iqpid.ops
Field
p18
(dp19
g13
Nsg14
S'sequence-no'
p20
sg16
S'id'
p21
sba(iqpid.ops
Field
p22
(dp23
g13
I00
sg14
S'bit'
p24
sg16
S'sync'
p25
sba(iqpid.ops
Field
p26
(dp27
g13
Nsg14
Nsg16
S'headers'
p28
sba(iqpid.ops
Field
p29
(dp30
g13
Nsg14
Nsg16
S'payload'
p31
sbasS'RESULT'
p32
NsS'PACK'
p33
I2
sS'__doc__'
p34
S'This command is complete when all prior commands are completed.'
p35
sS'SIZE'
p36
I0
stp37
a(S'ExecutionResult'
(g2
t(dp38
g4
I770
sg5
S'execution_result'
p39
sg7
(lp40
(iqpid.ops
Field
p41
(dp42
g13
Nsg14
S'sequence_no'
p43
sg16
S'command_id'
p44
sba(iqpid.ops
Field
p45
(dp46
g13
Nsg14
S'struct32'
p47
sg16
S'value'
p48
sbasg9
(lp49
g41
ag45
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command carries data resulting from the execution of a command.\n\n  command_id -- None\n\n  value -- None'
p50
sg36
I0
stp51
a(S'ExecutionException'
(g2
t(dp52
g4
I771
sg5
S'execution_exception'
p53
sg7
(lp54
(iqpid.ops
Field
p55
(dp56
g13
Nsg14
S'uint16'
p57
sg16
S'error_code'
p58
sba(iqpid.ops
Field
p59
(dp60
g13
Nsg14
S'sequence_no'
p61
sg16
S'command_id'
p62
sba(iqpid.ops
Field
p63
(dp64
g13
Nsg14
S'uint8'
p65
sg16
S'class_code'
p66
sba(iqpid.ops
Field
p67
(dp68
g13
Nsg14
S'uint8'
p69
sg16
S'command_code'
p70
sba(iqpid.ops
Field
p71
(dp72
g13
Nsg14
S'uint8'
p73
sg16
S'field_index'
p74
sba(iqpid.ops
Field
p75
(dp76
g13
Nsg14
S'str16'
p77
sg16
S'description'
p78
sba(iqpid.ops
Field
p79
(dp80
g13
Nsg14
S'map'
p81
sg16
S'error_info'
p82
sbasg9
(lp83
g55
ag59
ag63
ag67
ag71
ag75
ag79
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command informs a peer of an execution exception. The command-id,\nwhen given, correlates the error to a specific command.\n\n  error_code -- error code indicating the         type of error\n\n  command_id -- exceptional command\n\n    The command-id of the command which caused the exception. If the\n    exception was not caused by a specific command, this value is not\n    set.\n\n  class_code -- the class code of the command whose execution         gave rise to the error (if appropriate)\n\n  command_code -- the class code of the command whose execution         gave rise to the error (if appropriate)\n\n  field_index -- index of the exceptional field\n\n    The zero based index of the exceptional field within the arguments\n    to the exceptional command. If the exception was not caused by a\n    specific field, this value is not set.\n\n  description -- descriptive text on the exception\n\n    The description provided is implementation defined, but MUST be in\n    the language appropriate for the selected locale. The intention is\n    that this description is suitable for logging or alerting output.\n\n  error_info -- map to carry additional information about the         error'
p84
sg36
I0
stp85
a(S'MessageTransfer'
(g2
t(dp86
g4
I1025
sg5
S'message_transfer'
p87
sg7
(lp88
(iqpid.ops
Field
p89
(dp90
g13
Nsg14
S'str8'
p91
sg16
S'destination'
p92
sba(iqpid.ops
Field
p93
(dp94
g13
Nsg14
S'uint8'
p95
sg16
S'accept_mode'
p96
sba(iqpid.ops
Field
p97
(dp98
g13
Nsg14
S'uint8'
p99
sg16
S'acquire_mode'
p100
sbasg9
(lp101
g89
ag93
ag97
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command transfers a message between two peers. When a client uses\nthis command to publish a message to a broker, the destination\nidentifies a specific exchange. The message will then be routed to\nqueues as defined by the exchange configuration. The client may\nrequest a broker to transfer messages to it, from a particular queue,\nby issuing a subscribe command. The subscribe command specifies the\ndestination that the broker should use for any resulting transfers.\n\n  destination -- message destination\n\n    Specifies the destination to which the message is to be\n    transferred.\n\n  accept_mode -- None\n\n    Indicates whether message.accept, session.complete, or nothing at\n    all is required to indicate successful transfer of the message.\n\n  acquire_mode -- None\n\n    Indicates whether or not the transferred message has been\n    acquired.'
p102
sg36
I0
stp103
a(S'MessageAccept'
(g2
t(dp104
g4
I1026
sg5
S'message_accept'
p105
sg7
(lp106
(iqpid.ops
Field
p107
(dp108
g13
Nsg14
S'sequence_set'
p109
sg16
S'transfers'
p110
sbasg9
(lp111
g107
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'Accepts the message. Once a transfer is accepted, the command-id may\nno longer be referenced from other commands.\n\n  transfers -- None\n\n    Identifies the messages previously transferred that should be\n    accepted.'
p112
sg36
I0
stp113
a(S'MessageReject'
(g2
t(dp114
g4
I1027
sg5
S'message_reject'
p115
sg7
(lp116
(iqpid.ops
Field
p117
(dp118
g13
Nsg14
g109
sg16
S'transfers'
p119
sba(iqpid.ops
Field
p120
(dp121
g13
Nsg14
S'uint16'
p122
sg16
S'code'
p123
sba(iqpid.ops
Field
p124
(dp125
g13
Nsg14
S'str8'
p126
sg16
S'text'
p127
sbasg9
(lp128
g117
ag120
ag124
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'Indicates that the message transfers are unprocessable in some way. A\nserver may reject a message if it is unroutable. A client may reject a\nmessage if it is invalid. A message may be rejected for other reasons\nas well. Once a transfer is rejected, the command-id may no longer be\nreferenced from other commands.\n\n  transfers -- None\n\n    Identifies the messages previously transferred that should be\n    rejected.\n\n  code -- None\n\n    Code describing the reason for rejection.\n\n  text -- informational text for message reject\n\n    Text describing the reason for rejection.'
p129
sg36
I0
stp130
a(S'MessageRelease'
(g2
t(dp131
g4
I1028
sg5
S'message_release'
p132
sg7
(lp133
(iqpid.ops
Field
p134
(dp135
g13
Nsg14
g109
sg16
S'transfers'
p136
sba(iqpid.ops
Field
p137
(dp138
g13
I00
sg14
S'bit'
p139
sg16
S'set_redelivered'
p140
sbasg9
(lp141
g134
ag137
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'Release previously transferred messages. When acquired messages are\nreleased, they become available for acquisition by any subscriber.\nOnce a transfer is released, the command-id may no longer be\nreferenced from other commands.\n\n  transfers -- None\n\n    Indicates the messages to be released.\n\n  set_redelivered -- mark the released messages as redelivered\n\n    By setting set-redelivered to true, any acquired messages released\n    to a queue with this command will be marked as redelivered on\n    their next transfer from that queue. If this flag is not set, then\n    an acquired message will retain its original redelivered status on\n    the queue. Messages that are not acquired are unaffected by the\n    value of this flag.'
p142
sg36
I0
stp143
a(S'MessageAcquire'
(g2
t(dp144
g4
I1029
sg5
S'message_acquire'
p145
sg7
(lp146
(iqpid.ops
Field
p147
(dp148
g13
Nsg14
g109
sg16
S'transfers'
p149
sbasg9
(lp150
g147
ag11
ag18
ag22
ag26
ag29
asg32
S'acquired'
p151
sg33
I2
sg34
S'Acquires previously transferred messages for consumption. The acquired\nids (if any) are sent via message.acquired.\n\n  transfers -- None\n\n    Indicates the messages to be acquired.'
p152
sg36
I0
stp153
a(S'MessageResume'
(g2
t(dp154
g4
I1030
sg5
S'message_resume'
p155
sg7
(lp156
(iqpid.ops
Field
p157
(dp158
g13
Nsg14
g91
sg16
S'destination'
p159
sba(iqpid.ops
Field
p160
(dp161
g13
Nsg14
S'str16'
p162
sg16
S'resume_id'
p163
sbasg9
(lp164
g157
ag160
ag11
ag18
ag22
ag26
ag29
asg32
S'message_resume_result'
p165
sg33
I2
sg34
S'This command resumes an interrupted transfer. The recipient should\nreturn the amount of partially transferred data associated with the\ngiven resume-id, or zero if there is no data at all. If a non-zero\nresult is returned, the recipient should expect to receive message\nfragment(s) containing the remainder of the interrupted message.\n\n  destination -- None\n\n    The destination to which the remaining message fragments are\n    transferred.\n\n  resume_id -- None\n\n    The name of the transfer being resumed.'
p166
sg36
I0
stp167
a(S'MessageSubscribe'
(g2
t(dp168
g4
I1031
sg5
S'message_subscribe'
p169
sg7
(lp170
(iqpid.ops
Field
p171
(dp172
g13
Nsg14
S'str8'
p173
sg16
S'queue'
p174
sba(iqpid.ops
Field
p175
(dp176
g13
Nsg14
g91
sg16
S'destination'
p177
sba(iqpid.ops
Field
p178
(dp179
g13
Nsg14
g95
sg16
S'accept_mode'
p180
sba(iqpid.ops
Field
p181
(dp182
g13
Nsg14
g99
sg16
S'acquire_mode'
p183
sba(iqpid.ops
Field
p184
(dp185
g13
I00
sg14
S'bit'
p186
sg16
S'exclusive'
p187
sba(iqpid.ops
Field
p188
(dp189
g13
Nsg14
g162
sg16
S'resume_id'
p190
sba(iqpid.ops
Field
p191
(dp192
g13
Nsg14
S'uint64'
p193
sg16
S'resume_ttl'
p194
sba(iqpid.ops
Field
p195
(dp196
g13
Nsg14
S'map'
p197
sg16
S'arguments'
p198
sbasg9
(lp199
g171
ag175
ag178
ag181
ag184
ag188
ag191
ag195
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command asks the server to start a "subscription", which is a\nrequest for messages from a specific queue. Subscriptions last as long\nas the session they were created on, or until the client cancels them.\n\n  queue -- None\n\n    Specifies the name of the subscribed queue.\n\n  destination -- incoming message destination\n\n    The client specified name for the subscription. This is used as\n    the destination for all messages transferred from this\n    subscription. The destination is scoped to the session.\n\n  accept_mode -- None\n\n    The accept-mode to use for messages transferred from this\n    subscription.\n\n  acquire_mode -- None\n\n    The acquire-mode to use for messages transferred from this\n    subscription.\n\n  exclusive -- request exclusive access\n\n    Request an exclusive subscription. This prevents other subscribers\n    from subscribing to the queue.\n\n  resume_id -- None\n\n    Requests that the broker use the supplied resume-id when\n    transferring messages for this subscription.\n\n  resume_ttl -- None\n\n    Requested duration in milliseconds for the broker use as resume-\n    ttl when transferring messages for this subscription.\n\n  arguments -- arguments for vendor extensions\n\n    The syntax and semantics of these arguments depends on the\n    providers implementation.'
p200
sg36
I0
stp201
a(S'MessageCancel'
(g2
t(dp202
g4
I1032
sg5
S'message_cancel'
p203
sg7
(lp204
(iqpid.ops
Field
p205
(dp206
g13
Nsg14
g91
sg16
S'destination'
p207
sbasg9
(lp208
g205
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command cancels a subscription. This does not affect already\ndelivered messages, but it does mean the server will not send any more\nmessages for that subscription. The client may receive an arbitrary\nnumber of messages in between sending the cancel command and receiving\nnotification that the cancel command is complete.\n\n  destination -- None'
p209
sg36
I0
stp210
a(S'MessageSetFlowMode'
(g2
t(dp211
g4
I1033
sg5
S'message_set_flow_mode'
p212
sg7
(lp213
(iqpid.ops
Field
p214
(dp215
g13
Nsg14
g91
sg16
S'destination'
p216
sba(iqpid.ops
Field
p217
(dp218
g13
Nsg14
S'uint8'
p219
sg16
S'flow_mode'
p220
sbasg9
(lp221
g214
ag217
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'Sets the mode of flow control used for a given destination to either\nwindow or credit based flow control. With credit based flow control,\nthe sender of messages continually maintains its current credit\nbalance with the recipient. The credit balance consists of two values,\na message count, and a byte count. Whenever message data is sent, both\ncounts must be decremented. If either value reaches zero, the flow of\nmessage data must stop. Additional credit is received via the\nmessage.flow command. The sender MUST NOT send partial assemblies.\nThis means that if there is not enough byte credit available to send a\ncomplete message, the sender must either wait or use message\nfragmentation (see the fragment-properties header struct) to send the\nfirst part of the message data in a complete assembly. Window based\nflow control is identical to credit based flow control, however\nmessage transfer completion implicitly grants a single unit of message\ncredit, and the size of the message in byte credits for each completed\nmessage transfer. Completion of the transfer command with\nsession.completed is the only way credit is implicitly updated;\nmessage.accept, message.release, message.reject, tx.commit and\ntx.rollback have no effect on the outstanding credit balances.\n\n  destination -- None\n\n  flow_mode -- None\n\n    The new flow control mode.'
p222
sg36
I0
stp223
a(S'MessageFlow'
(g2
t(dp224
g4
I1034
sg5
S'message_flow'
p225
sg7
(lp226
(iqpid.ops
Field
p227
(dp228
g13
Nsg14
g91
sg16
S'destination'
p229
sba(iqpid.ops
Field
p230
(dp231
g13
Nsg14
S'uint8'
p232
sg16
S'unit'
p233
sba(iqpid.ops
Field
p234
(dp235
g13
Nsg14
S'uint32'
p236
sg16
S'value'
p237
sbasg9
(lp238
g227
ag230
ag234
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command controls the flow of message data to a given destination.\nIt is used by the recipient of messages to dynamically match the\nincoming rate of message flow to its processing or forwarding\ncapacity. Upon receipt of this command, the sender must add "value"\nnumber of the specified unit to the available credit balance for the\nspecified destination. A value of (0xFFFFFFFF) indicates an infinite\namount of credit. This disables any limit for the given unit until the\ncredit balance is zeroed with message.stop or message.flush.\n\n  destination -- None\n\n  unit -- None\n\n    The unit of value.\n\n  value -- None\n\n    If the value is not set then this indicates an infinite amount of\n    credit.'
p239
sg36
I0
stp240
a(S'MessageFlush'
(g2
t(dp241
g4
I1035
sg5
S'message_flush'
p242
sg7
(lp243
(iqpid.ops
Field
p244
(dp245
g13
Nsg14
g91
sg16
S'destination'
p246
sbasg9
(lp247
g244
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S"Forces the sender to exhaust his credit supply. The sender's credit\nwill always be zero when this command completes. The command completes\nwhen immediately available message data has been transferred, or when\nthe credit supply is exhausted.\n\n  destination -- None"
p248
sg36
I0
stp249
a(S'MessageStop'
(g2
t(dp250
g4
I1036
sg5
S'message_stop'
p251
sg7
(lp252
(iqpid.ops
Field
p253
(dp254
g13
Nsg14
g91
sg16
S'destination'
p255
sbasg9
(lp256
g253
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'On receipt of this command, a producer of messages MUST set his credit\nto zero for the given destination. When notifying of completion,\ncredit MUST be zero and no further messages will be sent until such a\ntime as further credit is received.\n\n  destination -- None'
p257
sg36
I0
stp258
a(S'TxSelect'
(g2
t(dp259
g4
I1281
sg5
S'tx_select'
p260
sg7
(lp261
sg9
(lp262
g11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command sets the session to use standard transactions. The client\nmust use this command exactly once on a session before using the\nCommit or Rollback commands.'
p263
sg36
I0
stp264
a(S'TxCommit'
(g2
t(dp265
g4
I1282
sg5
S'tx_commit'
p266
sg7
(lp267
sg9
(lp268
g11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command commits all messages published and accepted in the\ncurrent transaction. A new transaction starts immediately after a\ncommit.\n\nIn more detail, the commit acts on all messages which have been\ntransferred from the Client to the Server, and on all acceptances of\nmessages sent from Server to Client. Since the commit acts on commands\nsent in the same direction as the commit command itself, there is no\nambiguity on the scope of the commands being committed. Further, the\ncommit will not be completed until all preceding commands which it\naffects have been completed.\n\nSince transactions act on explicit accept commands, the only valid\naccept-mode for message subscribers is explicit. For transferring\nmessages from Client to Server (publishing) all accept-modes are\npermitted.'
p269
sg36
I0
stp270
a(S'TxRollback'
(g2
t(dp271
g4
I1283
sg5
S'tx_rollback'
p272
sg7
(lp273
sg9
(lp274
g11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command abandons the current transaction. In particular the\ntransfers from Client to Server (publishes) and accepts of transfers\nfrom Server to Client which occurred in the current transaction are\ndiscarded. A new transaction starts immediately after a rollback.\n\nIn more detail, when a rollback is issued, any the effects of\ntransfers which occurred from Client to Server are discarded. The\nServer will issue completion notification for all such transfers prior\nto the completion of the rollback. Similarly the effects of any\nmessage.accept issued from Client to Server prior to the issuance of\nthe tx.rollback will be discarded; and notification of completion for\nall such commands will be issued before the issuance of the completion\nfor the rollback.\n\nAfter the completion of the rollback, the client will still hold the\nmessages which it has not yet accepted (including those for which\naccepts were previously issued within the transaction); i.e. the\nmessages remain "acquired". If the Client wishes to release those\nmessages back to the Server, then appropriate message.release commands\nmust be issued.'
p275
sg36
I0
stp276
a(S'DtxSelect'
(g2
t(dp277
g4
I1537
sg5
S'dtx_select'
p278
sg7
(lp279
sg9
(lp280
g11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command sets the session to use distributed transactions. The\nclient must use this command at least once on a session before using\nXA demarcation operations.'
p281
sg36
I0
stp282
a(S'DtxStart'
(g2
t(dp283
g4
I1538
sg5
S'dtx_start'
p284
sg7
(lp285
(iqpid.ops
Field
p286
(dp287
g13
Nsg14
S'xid'
p288
sg16
S'xid'
p289
sba(iqpid.ops
Field
p290
(dp291
g13
I00
sg14
S'bit'
p292
sg16
S'join'
p293
sba(iqpid.ops
Field
p294
(dp295
g13
I00
sg14
S'bit'
p296
sg16
S'resume'
p297
sbasg9
(lp298
g286
ag290
ag294
ag11
ag18
ag22
ag26
ag29
asg32
S'xa_result'
p299
sg33
I2
sg34
S'This command is called when messages should be produced and consumed\non behalf a transaction branch identified by xid.\n\n  xid -- Transaction xid\n\n    Specifies the xid of the transaction branch to be started.\n\n  join -- Join with existing xid flag\n\n    Indicate whether this is joining an already associated xid.\n    Indicate that the start applies to joining a transaction\n    previously seen.\n\n  resume -- Resume flag\n\n    Indicate that the start applies to resuming a suspended\n    transaction branch specified.'
p300
sg36
I0
stp301
a(S'DtxEnd'
(g2
t(dp302
g4
I1539
sg5
S'dtx_end'
p303
sg7
(lp304
(iqpid.ops
Field
p305
(dp306
g13
Nsg14
S'xid'
p307
sg16
S'xid'
p308
sba(iqpid.ops
Field
p309
(dp310
g13
I00
sg14
S'bit'
p311
sg16
S'fail'
p312
sba(iqpid.ops
Field
p313
(dp314
g13
I00
sg14
S'bit'
p315
sg16
S'suspend'
p316
sbasg9
(lp317
g305
ag309
ag313
ag11
ag18
ag22
ag26
ag29
asg32
S'xa_result'
p318
sg33
I2
sg34
S'This command is called when the work done on behalf a transaction\nbranch finishes or needs to be suspended.\n\n  xid -- Transaction xid\n\n    Specifies the xid of the transaction branch to be ended.\n\n  fail -- Failure flag\n\n    If set, indicates that this portion of work has failed; otherwise\n    this portion of work has completed successfully.\n\n  suspend -- Temporary suspension flag\n\n    Indicates that the transaction branch is temporarily suspended in\n    an incomplete state.'
p319
sg36
I0
stp320
a(S'DtxCommit'
(g2
t(dp321
g4
I1540
sg5
S'dtx_commit'
p322
sg7
(lp323
(iqpid.ops
Field
p324
(dp325
g13
Nsg14
S'xid'
p326
sg16
S'xid'
p327
sba(iqpid.ops
Field
p328
(dp329
g13
I00
sg14
S'bit'
p330
sg16
S'one_phase'
p331
sbasg9
(lp332
g324
ag328
ag11
ag18
ag22
ag26
ag29
asg32
S'xa_result'
p333
sg33
I2
sg34
S'Commit the work done on behalf a transaction branch. This command\ncommits the work associated with xid. Any produced messages are made\navailable and any consumed messages are discarded.\n\n  xid -- Transaction xid\n\n    Specifies the xid of the transaction branch to be committed.\n\n  one_phase -- One-phase optimization flag\n\n    Used to indicate whether one-phase or two-phase commit is used.'
p334
sg36
I0
stp335
a(S'DtxForget'
(g2
t(dp336
g4
I1541
sg5
S'dtx_forget'
p337
sg7
(lp338
(iqpid.ops
Field
p339
(dp340
g13
Nsg14
S'xid'
p341
sg16
S'xid'
p342
sbasg9
(lp343
g339
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command is called to forget about a heuristically completed\ntransaction branch.\n\n  xid -- Transaction xid\n\n    Specifies the xid of the transaction branch to be forgotten.'
p344
sg36
I0
stp345
a(S'DtxGetTimeout'
(g2
t(dp346
g4
I1542
sg5
S'dtx_get_timeout'
p347
sg7
(lp348
(iqpid.ops
Field
p349
(dp350
g13
Nsg14
S'xid'
p351
sg16
S'xid'
p352
sbasg9
(lp353
g349
ag11
ag18
ag22
ag26
ag29
asg32
S'get_timeout_result'
p354
sg33
I2
sg34
S'This command obtains the current transaction timeout value in seconds.\nIf set-timeout was not used prior to invoking this command, the return\nvalue is the default timeout; otherwise, the value used in the\nprevious set-timeout call is returned.\n\n  xid -- Transaction xid\n\n    Specifies the xid of the transaction branch for getting the\n    timeout.'
p355
sg36
I0
stp356
a(S'DtxPrepare'
(g2
t(dp357
g4
I1543
sg5
S'dtx_prepare'
p358
sg7
(lp359
(iqpid.ops
Field
p360
(dp361
g13
Nsg14
S'xid'
p362
sg16
S'xid'
p363
sbasg9
(lp364
g360
ag11
ag18
ag22
ag26
ag29
asg32
S'xa_result'
p365
sg33
I2
sg34
S'This command prepares for commitment any message produced or consumed\non behalf of xid.\n\n  xid -- Transaction xid\n\n    Specifies the xid of the transaction branch that can be prepared.'
p366
sg36
I0
stp367
a(S'DtxRecover'
(g2
t(dp368
g4
I1544
sg5
S'dtx_recover'
p369
sg7
(lp370
sg9
(lp371
g11
ag18
ag22
ag26
ag29
asg32
S'recover_result'
p372
sg33
I2
sg34
S'This command is called to obtain a list of transaction branches that\nare in a prepared or heuristically completed state.'
p373
sg36
I0
stp374
a(S'DtxRollback'
(g2
t(dp375
g4
I1545
sg5
S'dtx_rollback'
p376
sg7
(lp377
(iqpid.ops
Field
p378
(dp379
g13
Nsg14
S'xid'
p380
sg16
S'xid'
p381
sbasg9
(lp382
g378
ag11
ag18
ag22
ag26
ag29
asg32
S'xa_result'
p383
sg33
I2
sg34
S'This command rolls back the work associated with xid. Any produced\nmessages are discarded and any consumed messages are re-enqueued.\n\n  xid -- Transaction xid\n\n    Specifies the xid of the transaction branch that can be rolled\n    back.'
p384
sg36
I0
stp385
a(S'DtxSetTimeout'
(g2
t(dp386
g4
I1546
sg5
S'dtx_set_timeout'
p387
sg7
(lp388
(iqpid.ops
Field
p389
(dp390
g13
Nsg14
S'xid'
p391
sg16
S'xid'
p392
sba(iqpid.ops
Field
p393
(dp394
g13
Nsg14
S'uint32'
p395
sg16
S'timeout'
p396
sbasg9
(lp397
g389
ag393
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'Sets the specified transaction branch timeout value in seconds.\n\n  xid -- Transaction xid\n\n    Specifies the xid of the transaction branch for setting the\n    timeout.\n\n  timeout -- Dtx timeout in seconds\n\n    The transaction timeout value in seconds.'
p398
sg36
I0
stp399
a(S'ExchangeDeclare'
(g2
t(dp400
g4
I1793
sg5
S'exchange_declare'
p401
sg7
(lp402
(iqpid.ops
Field
p403
(dp404
g13
Nsg14
S'str8'
p405
sg16
S'exchange'
p406
sba(iqpid.ops
Field
p407
(dp408
g13
Nsg14
S'str8'
p409
sg16
S'type'
p410
sba(iqpid.ops
Field
p411
(dp412
g13
Nsg14
g405
sg16
S'alternate_exchange'
p413
sba(iqpid.ops
Field
p414
(dp415
g13
I00
sg14
S'bit'
p416
sg16
S'passive'
p417
sba(iqpid.ops
Field
p418
(dp419
g13
I00
sg14
S'bit'
p420
sg16
S'durable'
p421
sba(iqpid.ops
Field
p422
(dp423
g13
I00
sg14
S'bit'
p424
sg16
S'auto_delete'
p425
sba(iqpid.ops
Field
p426
(dp427
g13
Nsg14
S'map'
p428
sg16
S'arguments'
p429
sbasg9
(lp430
g403
ag407
ag411
ag414
ag418
ag422
ag426
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command creates an exchange if it does not already exist, and if\nthe exchange exists, verifies that it is of the correct and expected\nclass.\n\n  exchange -- None\n\n  type -- exchange type\n\n    Each exchange belongs to one of a set of exchange types\n    implemented by the server. The exchange types define the\n    functionality of the exchange - i.e. how messages are routed\n    through it. It is not valid or meaningful to attempt to change the\n    type of an existing exchange.\n\n  alternate_exchange -- exchange name for unroutable messages\n\n    In the event that a message cannot be routed, this is the name of\n    the exchange to which the message will be sent. Messages\n    transferred using message.transfer will be routed to the\n    alternate-exchange only if they are sent with the "none" accept-\n    mode, and the discard-unroutable delivery property is set to\n    false, and there is no queue to route to for the given message\n    according to the bindings on this exchange.\n\n  passive -- do not create exchange\n\n    If set, the server will not create the exchange. The client can\n    use this to check whether an exchange exists without modifying the\n    server state.\n\n  durable -- request a durable exchange\n\n    If set when creating a new exchange, the exchange will be marked\n    as durable. Durable exchanges remain active when a server\n    restarts. Non-durable exchanges (transient exchanges) are purged\n    if/when a server restarts.\n\n  auto_delete -- auto-delete when unused\n\n    If set, the exchange is deleted automatically when there remain no\n    bindings between the exchange and any queue. Such an exchange will\n    not be automatically deleted until at least one binding has been\n    made to prevent the immediate deletion of the exchange upon\n    creation.\n\n  arguments -- arguments for declaration\n\n    A set of arguments for the declaration. The syntax and semantics\n    of these arguments depends on the server implementation. This\n    field is ignored if passive is 1.'
p431
sg36
I0
stp432
a(S'ExchangeDelete'
(g2
t(dp433
g4
I1794
sg5
S'exchange_delete'
p434
sg7
(lp435
(iqpid.ops
Field
p436
(dp437
g13
Nsg14
g405
sg16
S'exchange'
p438
sba(iqpid.ops
Field
p439
(dp440
g13
I00
sg14
S'bit'
p441
sg16
S'if_unused'
p442
sbasg9
(lp443
g436
ag439
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command deletes an exchange. When an exchange is deleted all\nqueue bindings on the exchange are cancelled.\n\n  exchange -- None\n\n  if_unused -- delete only if unused\n\n    If set, the server will only delete the exchange if it has no\n    queue bindings. If the exchange has queue bindings the server does\n    not delete it but raises an exception instead.'
p444
sg36
I0
stp445
a(S'ExchangeQuery'
(g2
t(dp446
g4
I1795
sg5
S'exchange_query'
p447
sg7
(lp448
(iqpid.ops
Field
p449
(dp450
g13
Nsg14
S'str8'
p451
sg16
S'name'
p452
sbasg9
(lp453
g449
ag11
ag18
ag22
ag26
ag29
asg32
S'exchange_query_result'
p454
sg33
I2
sg34
S'This command is used to request information on a particular exchange.\n\n  name -- the exchange name\n\n    The name of the exchange for which information is requested. If\n    not specified explicitly the default exchange is implied.'
p455
sg36
I0
stp456
a(S'ExchangeBind'
(g2
t(dp457
g4
I1796
sg5
S'exchange_bind'
p458
sg7
(lp459
(iqpid.ops
Field
p460
(dp461
g13
Nsg14
g173
sg16
S'queue'
p462
sba(iqpid.ops
Field
p463
(dp464
g13
Nsg14
g405
sg16
S'exchange'
p465
sba(iqpid.ops
Field
p466
(dp467
g13
Nsg14
S'str8'
p468
sg16
S'binding_key'
p469
sba(iqpid.ops
Field
p470
(dp471
g13
Nsg14
S'map'
p472
sg16
S'arguments'
p473
sbasg9
(lp474
g460
ag463
ag466
ag470
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command binds a queue to an exchange. Until a queue is bound it\nwill not receive any messages. In a classic messaging model, store-\nand-forward queues are bound to a direct exchange and subscription\nqueues are bound to a topic exchange.\n\n  queue -- None\n\n    Specifies the name of the queue to bind.\n\n  exchange -- name of the exchange to bind to\n\n  binding_key -- identifies a binding between a given exchange and queue\n\n    The binding-key uniquely identifies a binding between a given\n    (exchange, queue) pair. Depending on the exchange configuration,\n    the binding key may be matched against the message routing key in\n    order to make routing decisions. The match algorithm depends on\n    the exchange type. Some exchange types may ignore the binding key\n    when making routing decisions. Refer to the specific exchange type\n    documentation. The meaning of an empty binding key depends on the\n    exchange implementation.\n\n  arguments -- arguments for binding\n\n    A set of arguments for the binding. The syntax and semantics of\n    these arguments depends on the exchange class.'
p475
sg36
I0
stp476
a(S'ExchangeUnbind'
(g2
t(dp477
g4
I1797
sg5
S'exchange_unbind'
p478
sg7
(lp479
(iqpid.ops
Field
p480
(dp481
g13
Nsg14
g173
sg16
S'queue'
p482
sba(iqpid.ops
Field
p483
(dp484
g13
Nsg14
g405
sg16
S'exchange'
p485
sba(iqpid.ops
Field
p486
(dp487
g13
Nsg14
S'str8'
p488
sg16
S'binding_key'
p489
sbasg9
(lp490
g480
ag483
ag486
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command unbinds a queue from an exchange.\n\n  queue -- None\n\n    Specifies the name of the queue to unbind.\n\n  exchange -- None\n\n    The name of the exchange to unbind from.\n\n  binding_key -- the key of the binding\n\n    Specifies the binding-key of the binding to unbind.'
p491
sg36
I0
stp492
a(S'ExchangeBound'
(g2
t(dp493
g4
I1798
sg5
S'exchange_bound'
p494
sg7
(lp495
(iqpid.ops
Field
p496
(dp497
g13
Nsg14
S'str8'
p498
sg16
S'exchange'
p499
sba(iqpid.ops
Field
p500
(dp501
g13
Nsg14
S'str8'
p502
sg16
S'queue'
p503
sba(iqpid.ops
Field
p504
(dp505
g13
Nsg14
S'str8'
p506
sg16
S'binding_key'
p507
sba(iqpid.ops
Field
p508
(dp509
g13
Nsg14
S'map'
p510
sg16
S'arguments'
p511
sbasg9
(lp512
g496
ag500
ag504
ag508
ag11
ag18
ag22
ag26
ag29
asg32
S'exchange_bound_result'
p513
sg33
I2
sg34
S'This command is used to request information on the bindings to a\nparticular exchange.\n\n  exchange -- the exchange name\n\n    The name of the exchange for which binding information is being\n    requested. If not specified explicitly the default exchange is\n    implied.\n\n  queue -- a queue name\n\n    If populated then determine whether the given queue is bound to\n    the exchange.\n\n  binding_key -- a binding-key\n\n    If populated defines the binding-key of the binding of interest,\n    if not populated the request will ignore the binding-key on\n    bindings when searching for a match.\n\n  arguments -- a set of binding arguments\n\n    If populated defines the arguments of the binding of interest if\n    not populated the request will ignore the arguments on bindings\n    when searching for a match'
p514
sg36
I0
stp515
a(S'QueueDeclare'
(g2
t(dp516
g4
I2049
sg5
S'queue_declare'
p517
sg7
(lp518
(iqpid.ops
Field
p519
(dp520
g13
Nsg14
g173
sg16
S'queue'
p521
sba(iqpid.ops
Field
p522
(dp523
g13
Nsg14
g405
sg16
S'alternate_exchange'
p524
sba(iqpid.ops
Field
p525
(dp526
g13
I00
sg14
S'bit'
p527
sg16
S'passive'
p528
sba(iqpid.ops
Field
p529
(dp530
g13
I00
sg14
S'bit'
p531
sg16
S'durable'
p532
sba(iqpid.ops
Field
p533
(dp534
g13
I00
sg14
S'bit'
p535
sg16
S'exclusive'
p536
sba(iqpid.ops
Field
p537
(dp538
g13
I00
sg14
S'bit'
p539
sg16
S'auto_delete'
p540
sba(iqpid.ops
Field
p541
(dp542
g13
Nsg14
S'map'
p543
sg16
S'arguments'
p544
sbasg9
(lp545
g519
ag522
ag525
ag529
ag533
ag537
ag541
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S"This command creates or checks a queue. When creating a new queue the\nclient can specify various properties that control the durability of\nthe queue and its contents, and the level of sharing for the queue.\n\n  queue -- None\n\n  alternate_exchange -- exchange name for messages with exceptions\n\n    The alternate-exchange field specifies how messages on this queue\n    should be treated when they are rejected by a subscriber, or when\n    they are orphaned by queue deletion. When present, rejected or\n    orphaned messages MUST be routed to the alternate-exchange. In all\n    cases the messages MUST be removed from the queue.\n\n  passive -- do not create queue\n\n    If set, the server will not create the queue. This field allows\n    the client to assert the presence of a queue without modifying the\n    server state.\n\n  durable -- request a durable queue\n\n    If set when creating a new queue, the queue will be marked as\n    durable. Durable queues remain active when a server restarts. Non-\n    durable queues (transient queues) are purged if/when a server\n    restarts. Note that durable queues do not necessarily hold\n    persistent messages, although it does not make sense to send\n    persistent messages to a transient queue.\n\n  exclusive -- request an exclusive queue\n\n    Exclusive queues can only be used from one session at a time. Once\n    a session declares an exclusive queue, that queue cannot be used\n    by any other session until the declaring session closes.\n\n  auto_delete -- auto-delete queue when unused\n\n    If this field is set and the exclusive field is also set, then the\n    queue MUST be deleted when the session closes. If this field is\n    set and the exclusive field is not set the queue is deleted when\n    all the consumers have finished using it. Last consumer can be\n    cancelled either explicitly or because its session is closed. If\n    there was no consumer ever on the queue, it won't be deleted.\n\n  arguments -- arguments for declaration\n\n    A set of arguments for the declaration. The syntax and semantics\n    of these arguments depends on the server implementation. This\n    field is ignored if passive is 1."
p546
sg36
I0
stp547
a(S'QueueDelete'
(g2
t(dp548
g4
I2050
sg5
S'queue_delete'
p549
sg7
(lp550
(iqpid.ops
Field
p551
(dp552
g13
Nsg14
g173
sg16
S'queue'
p553
sba(iqpid.ops
Field
p554
(dp555
g13
I00
sg14
S'bit'
p556
sg16
S'if_unused'
p557
sba(iqpid.ops
Field
p558
(dp559
g13
I00
sg14
S'bit'
p560
sg16
S'if_empty'
p561
sbasg9
(lp562
g551
ag554
ag558
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command deletes a queue. When a queue is deleted any pending\nmessages are sent to the alternate-exchange if defined, or discarded\nif it is not.\n\n  queue -- None\n\n    Specifies the name of the queue to delete.\n\n  if_unused -- delete only if unused\n\n    If set, the server will only delete the queue if it has no\n    consumers. If the queue has consumers the server does does not\n    delete it but raises an exception instead.\n\n  if_empty -- delete only if empty\n\n    If set, the server will only delete the queue if it has no\n    messages.'
p563
sg36
I0
stp564
a(S'QueuePurge'
(g2
t(dp565
g4
I2051
sg5
S'queue_purge'
p566
sg7
(lp567
(iqpid.ops
Field
p568
(dp569
g13
Nsg14
g173
sg16
S'queue'
p570
sbasg9
(lp571
g568
ag11
ag18
ag22
ag26
ag29
asg32
Nsg33
I2
sg34
S'This command removes all messages from a queue. It does not cancel\nsubscribers. Purged messages are deleted without any formal "undo"\nmechanism.\n\n  queue -- None\n\n    Specifies the name of the queue to purge.'
p572
sg36
I0
stp573
a(S'QueueQuery'
(g2
t(dp574
g4
I2052
sg5
S'queue_query'
p575
sg7
(lp576
(iqpid.ops
Field
p577
(dp578
g13
Nsg14
g173
sg16
S'queue'
p579
sbasg9
(lp580
g577
ag11
ag18
ag22
ag26
ag29
asg32
S'queue_query_result'
p581
sg33
I2
sg34
S'This command requests information about a queue.\n\n  queue -- the queried queue'
p582
sg36
I0
stp583
a(S'ConnectionStart'
(cqpid.ops
Control
p584
t(dp585
g4
I257
sg5
S'connection_start'
p586
sg7
(lp587
(iqpid.ops
Field
p588
(dp589
g13
Nsg14
S'map'
p590
sg16
S'server_properties'
p591
sba(iqpid.ops
Field
p592
(dp593
g13
Nsg14
S'array'
p594
sg16
S'mechanisms'
p595
sba(iqpid.ops
Field
p596
(dp597
g13
Nsg14
g594
sg16
S'locales'
p598
sbasg9
(lp599
g588
ag592
ag596
a(iqpid.ops
Field
p600
(dp601
g13
I0
sg14
g15
sg16
g17
sbasg33
I2
sg34
S'This control starts the connection negotiation process by telling the\nclient the supported security mechanisms and locales from which the\nclient can choose.\n\n  server_properties -- server properties\n\n  mechanisms -- available security mechanisms\n\n    A list of the security mechanisms that the server supports.\n\n  locales -- available message locales\n\n    A list of the message locales that the server supports. The locale\n    defines the language in which the server will send reply texts.'
p602
sg36
I0
stp603
a(S'ConnectionStartOk'
(g584
t(dp604
g4
I258
sg5
S'connection_start_ok'
p605
sg7
(lp606
(iqpid.ops
Field
p607
(dp608
g13
Nsg14
S'map'
p609
sg16
S'client_properties'
p610
sba(iqpid.ops
Field
p611
(dp612
g13
Nsg14
S'str8'
p613
sg16
S'mechanism'
p614
sba(iqpid.ops
Field
p615
(dp616
g13
Nsg14
S'vbin32'
p617
sg16
S'response'
p618
sba(iqpid.ops
Field
p619
(dp620
g13
Nsg14
S'str8'
p621
sg16
S'locale'
p622
sbasg9
(lp623
g607
ag611
ag615
ag619
ag600
asg33
I2
sg34
S'This control selects a SASL security mechanism.\n\n  client_properties -- client properties\n\n  mechanism -- selected security mechanism\n\n    A single security mechanisms selected by the client, which must be\n    one of those specified by the server.\n\n  response -- security response data\n\n    A block of opaque data passed to the security mechanism. The\n    contents of this data are defined by the SASL security mechanism.\n\n  locale -- selected message locale\n\n    A single message locale selected by the client, which must be one\n    of those specified by the server.'
p624
sg36
I0
stp625
a(S'ConnectionSecure'
(g584
t(dp626
g4
I259
sg5
S'connection_secure'
p627
sg7
(lp628
(iqpid.ops
Field
p629
(dp630
g13
Nsg14
S'vbin32'
p631
sg16
S'challenge'
p632
sbasg9
(lp633
g629
ag600
asg33
I2
sg34
S'The SASL protocol works by exchanging challenges and responses until\nboth peers have received sufficient information to authenticate each\nother. This control challenges the client to provide more information.\n\n  challenge -- security challenge data\n\n    Challenge information, a block of opaque binary data passed to the\n    security mechanism.'
p634
sg36
I0
stp635
a(S'ConnectionSecureOk'
(g584
t(dp636
g4
I260
sg5
S'connection_secure_ok'
p637
sg7
(lp638
(iqpid.ops
Field
p639
(dp640
g13
Nsg14
S'vbin32'
p641
sg16
S'response'
p642
sbasg9
(lp643
g639
ag600
asg33
I2
sg34
S'This control attempts to authenticate, passing a block of SASL data\nfor the security mechanism at the server side.\n\n  response -- security response data\n\n    A block of opaque data passed to the security mechanism. The\n    contents of this data are defined by the SASL security mechanism.'
p644
sg36
I0
stp645
a(S'ConnectionTune'
(g584
t(dp646
g4
I261
sg5
S'connection_tune'
p647
sg7
(lp648
(iqpid.ops
Field
p649
(dp650
g13
Nsg14
S'uint16'
p651
sg16
S'channel_max'
p652
sba(iqpid.ops
Field
p653
(dp654
g13
Nsg14
S'uint16'
p655
sg16
S'max_frame_size'
p656
sba(iqpid.ops
Field
p657
(dp658
g13
Nsg14
S'uint16'
p659
sg16
S'heartbeat_min'
p660
sba(iqpid.ops
Field
p661
(dp662
g13
Nsg14
S'uint16'
p663
sg16
S'heartbeat_max'
p664
sbasg9
(lp665
g649
ag653
ag657
ag661
ag600
asg33
I2
sg34
S'This control proposes a set of connection configuration values to the\nclient. The client can accept and/or adjust these.\n\n  channel_max -- proposed maximum channels\n\n    The maximum total number of channels that the server allows per\n    connection. If this is not set it means that the server does not\n    impose a fixed limit, but the number of allowed channels may be\n    limited by available server resources.\n\n  max_frame_size -- proposed maximum frame size\n\n    The largest frame size that the server proposes for the\n    connection. The client can negotiate a lower value. If this is not\n    set means that the server does not impose any specific limit but\n    may reject very large frames if it cannot allocate resources for\n    them.\n\n  heartbeat_min -- the minimum supported heartbeat delay\n\n    The minimum delay, in seconds, of the connection heartbeat\n    supported by the server. If this is not set it means the server\n    does not support sending heartbeats.\n\n  heartbeat_max -- the maximum supported heartbeat delay\n\n    The maximum delay, in seconds, of the connection heartbeat\n    supported by the server. If this is not set it means the server\n    has no maximum.'
p666
sg36
I0
stp667
a(S'ConnectionTuneOk'
(g584
t(dp668
g4
I262
sg5
S'connection_tune_ok'
p669
sg7
(lp670
(iqpid.ops
Field
p671
(dp672
g13
Nsg14
S'uint16'
p673
sg16
S'channel_max'
p674
sba(iqpid.ops
Field
p675
(dp676
g13
Nsg14
S'uint16'
p677
sg16
S'max_frame_size'
p678
sba(iqpid.ops
Field
p679
(dp680
g13
Nsg14
S'uint16'
p681
sg16
S'heartbeat'
p682
sbasg9
(lp683
g671
ag675
ag679
ag600
asg33
I2
sg34
S"This control sends the client's connection tuning parameters to the\nserver. Certain fields are negotiated, others provide capability\ninformation.\n\n  channel_max -- negotiated maximum channels\n\n    The maximum total number of channels that the client will use per\n    connection.\n\n  max_frame_size -- negotiated maximum frame size\n\n    The largest frame size that the client and server will use for the\n    connection. If it is not set means that the client does not impose\n    any specific limit but may reject very large frames if it cannot\n    allocate resources for them. Note that the max-frame-size limit\n    applies principally to content frames, where large contents can be\n    broken into frames of arbitrary size.\n\n  heartbeat -- negotiated heartbeat delay\n\n    The delay, in seconds, of the connection heartbeat chosen by the\n    client. If it is not set it means the client does not want a\n    heartbeat."
p684
sg36
I0
stp685
a(S'ConnectionOpen'
(g584
t(dp686
g4
I263
sg5
S'connection_open'
p687
sg7
(lp688
(iqpid.ops
Field
p689
(dp690
g13
Nsg14
S'str8'
p691
sg16
S'virtual_host'
p692
sba(iqpid.ops
Field
p693
(dp694
g13
Nsg14
g594
sg16
S'capabilities'
p695
sba(iqpid.ops
Field
p696
(dp697
g13
I00
sg14
S'bit'
p698
sg16
S'insist'
p699
sbasg9
(lp700
g689
ag693
ag696
ag600
asg33
I2
sg34
S"This control opens a connection to a virtual host, which is a\ncollection of resources, and acts to separate multiple application\ndomains within a server. The server may apply arbitrary limits per\nvirtual host, such as the number of each type of entity that may be\nused, per connection and/or in total.\n\n  virtual_host -- virtual host name\n\n    The name of the virtual host to work with.\n\n  capabilities -- required capabilities\n\n    The client can specify zero or more capability names. The server\n    can use this to determine how to process the client's connection\n    request.\n\n  insist -- insist on connecting to server\n\n    In a configuration with multiple collaborating servers, the server\n    may respond to a connection.open control with a\n    Connection.Redirect. The insist option tells the server that the\n    client is insisting on a connection to the specified server."
p701
sg36
I0
stp702
a(S'ConnectionOpenOk'
(g584
t(dp703
g4
I264
sg5
S'connection_open_ok'
p704
sg7
(lp705
(iqpid.ops
Field
p706
(dp707
g13
Nsg14
S'array'
p708
sg16
S'known_hosts'
p709
sbasg9
(lp710
g706
ag600
asg33
I2
sg34
S'This control signals to the client that the connection is ready for\nuse.\n\n  known_hosts -- alternate hosts which may be used in         the case of failure\n\n    Specifies an array of equivalent or alternative hosts that the\n    server knows about, which will normally include the current server\n    itself. Each entry in the array will be in the form of an IP\n    address or DNS name, optionally followed by a colon and a port\n    number. Clients can cache this information and use it when\n    reconnecting to a server after a failure. This field may be empty.'
p711
sg36
I0
stp712
a(S'ConnectionRedirect'
(g584
t(dp713
g4
I265
sg5
S'connection_redirect'
p714
sg7
(lp715
(iqpid.ops
Field
p716
(dp717
g13
Nsg14
S'str16'
p718
sg16
S'host'
p719
sba(iqpid.ops
Field
p720
(dp721
g13
Nsg14
g708
sg16
S'known_hosts'
p722
sbasg9
(lp723
g716
ag720
ag600
asg33
I2
sg34
S'This control redirects the client to another server, based on the\nrequested virtual host and/or capabilities.\n\n  host -- server to connect to\n\n    Specifies the server to connect to.\n\n  known_hosts -- alternate hosts to try in case of         failure\n\n    An array of equivalent or alternative hosts that the server knows\n    about.'
p724
sg36
I0
stp725
a(S'ConnectionHeartbeat'
(g584
t(dp726
g4
I266
sg5
S'connection_heartbeat'
p727
sg7
(lp728
sg9
(lp729
g600
asg33
I2
sg34
S'The heartbeat control may be used to generate artificial network\ntraffic when a connection is idle. If a connection is idle for more\nthan twice the negotiated heartbeat delay, the peers MAY be considered\ndisconnected.'
p730
sg36
I0
stp731
a(S'ConnectionClose'
(g584
t(dp732
g4
I267
sg5
S'connection_close'
p733
sg7
(lp734
(iqpid.ops
Field
p735
(dp736
g13
Nsg14
S'uint16'
p737
sg16
S'reply_code'
p738
sba(iqpid.ops
Field
p739
(dp740
g13
Nsg14
S'str8'
p741
sg16
S'reply_text'
p742
sbasg9
(lp743
g735
ag739
ag600
asg33
I2
sg34
S'This control indicates that the sender wants to close the connection.\nThe reason for close is indicated with the reply-code and reply-text.\nThe channel this control is sent on MAY be used to indicate which\nchannel caused the connection to close.\n\n  reply_code -- the numeric reply code\n\n    Indicates the reason for connection closure.\n\n  reply_text -- the localized reply text\n\n    This text can be logged as an aid to resolving issues.'
p744
sg36
I0
stp745
a(S'ConnectionCloseOk'
(g584
t(dp746
g4
I268
sg5
S'connection_close_ok'
p747
sg7
(lp748
sg9
(lp749
g600
asg33
I2
sg34
S'This control confirms a connection.close control and tells the\nrecipient that it is safe to release resources for the connection and\nclose the socket.'
p750
sg36
I0
stp751
a(S'SessionAttach'
(g584
t(dp752
g4
I513
sg5
S'session_attach'
p753
sg7
(lp754
(iqpid.ops
Field
p755
(dp756
g13
Nsg14
S'vbin16'
p757
sg16
S'name'
p758
sba(iqpid.ops
Field
p759
(dp760
g13
I00
sg14
S'bit'
p761
sg16
S'force'
p762
sbasg9
(lp763
g755
ag759
ag600
asg33
I2
sg34
S'Requests that the current transport be attached to the named session.\nSuccess or failure will be indicated with an attached or detached\nresponse. This control is idempotent.\n\n  name -- the session name\n\n    Identifies the session to be attached to the current transport.\n\n  force -- force attachment to a busy session\n\n    If set then a busy session will be forcibly detached from its\n    other transport and reattached to the current transport.'
p764
sg36
I0
stp765
a(S'SessionAttached'
(g584
t(dp766
g4
I514
sg5
S'session_attached'
p767
sg7
(lp768
(iqpid.ops
Field
p769
(dp770
g13
Nsg14
g757
sg16
S'name'
p771
sbasg9
(lp772
g769
ag600
asg33
I2
sg34
S'Confirms successful attachment of the transport to the named session.\n\n  name -- the session name\n\n    Identifies the session now attached to the current transport.'
p773
sg36
I0
stp774
a(S'SessionDetach'
(g584
t(dp775
g4
I515
sg5
S'session_detach'
p776
sg7
(lp777
(iqpid.ops
Field
p778
(dp779
g13
Nsg14
g757
sg16
S'name'
p780
sbasg9
(lp781
g778
ag600
asg33
I2
sg34
S'Detaches the current transport from the named session.\n\n  name -- the session name\n\n    Identifies the session to detach.'
p782
sg36
I0
stp783
a(S'SessionDetached'
(g584
t(dp784
g4
I516
sg5
S'session_detached'
p785
sg7
(lp786
(iqpid.ops
Field
p787
(dp788
g13
Nsg14
g757
sg16
S'name'
p789
sba(iqpid.ops
Field
p790
(dp791
g13
Nsg14
S'uint8'
p792
sg16
S'code'
p793
sbasg9
(lp794
g787
ag790
ag600
asg33
I2
sg34
S'Confirms detachment of the current transport from the named session.\n\n  name -- the session name\n\n    Identifies the detached session.\n\n  code -- the reason for detach\n\n    Identifies the reason for detaching from the named session.'
p795
sg36
I0
stp796
a(S'SessionRequestTimeout'
(g584
t(dp797
g4
I517
sg5
S'session_request_timeout'
p798
sg7
(lp799
(iqpid.ops
Field
p800
(dp801
g13
Nsg14
S'uint32'
p802
sg16
S'timeout'
p803
sbasg9
(lp804
g800
ag600
asg33
I2
sg34
S'This control may be sent by either the sender or receiver of commands.\nIt requests that the execution timeout be changed. This is the minimum\namount of time that a peer must preserve execution state for a\ndetached session.\n\n  timeout -- the requested timeout\n\n    The requested timeout for execution state in seconds. If not set,\n    this control requests that execution state is preserved\n    indefinitely.'
p805
sg36
I0
stp806
a(S'SessionTimeout'
(g584
t(dp807
g4
I518
sg5
S'session_timeout'
p808
sg7
(lp809
(iqpid.ops
Field
p810
(dp811
g13
Nsg14
S'uint32'
p812
sg16
S'timeout'
p813
sbasg9
(lp814
g810
ag600
asg33
I2
sg34
S'This control may be sent by the either the sender or receiver of\ncommands. It is a one-to-one reply to the request-timeout control that\nindicates the granted timeout for execution state.\n\n  timeout -- the execution timeout\n\n    The timeout for execution state. If not set, then execution state\n    is preserved indefinitely.'
p815
sg36
I0
stp816
a(S'SessionCommandPoint'
(g584
t(dp817
g4
I519
sg5
S'session_command_point'
p818
sg7
(lp819
(iqpid.ops
Field
p820
(dp821
g13
Nsg14
S'sequence_no'
p822
sg16
S'command_id'
p823
sba(iqpid.ops
Field
p824
(dp825
g13
Nsg14
S'uint64'
p826
sg16
S'command_offset'
p827
sbasg9
(lp828
g820
ag824
ag600
asg33
I2
sg34
S'This control is sent by the sender of commands and handled by the\nreceiver of commands. This establishes the sequence numbers associated\nwith all subsequent command data sent from the sender to the receiver.\nThe subsequent command data will be numbered starting with the values\nsupplied in this control and proceeding sequentially. This must be\nused at least once prior to sending any command data on newly attached\ntransports.\n\n  command_id -- the command-id of the next command\n\n  command_offset -- the byte offset within the command'
p829
sg36
I0
stp830
a(S'SessionExpected'
(g584
t(dp831
g4
I520
sg5
S'session_expected'
p832
sg7
(lp833
(iqpid.ops
Field
p834
(dp835
g13
Nsg14
g109
sg16
S'commands'
p836
sba(iqpid.ops
Field
p837
(dp838
g13
Nsg14
S'array'
p839
sg16
S'fragments'
p840
sbasg9
(lp841
g834
ag837
ag600
asg33
I2
sg34
S'This control is sent by the receiver of commands and handled by the\nsender of commands. It informs the sender of what commands and command\nfragments are expected at the receiver. This control is only sent in\nresponse to a flush control with the expected flag set. The expected\ncontrol is never sent spontaneously.\n\n  commands -- expected commands\n\n  fragments -- expected fragments'
p842
sg36
I0
stp843
a(S'SessionConfirmed'
(g584
t(dp844
g4
I521
sg5
S'session_confirmed'
p845
sg7
(lp846
(iqpid.ops
Field
p847
(dp848
g13
Nsg14
g109
sg16
S'commands'
p849
sba(iqpid.ops
Field
p850
(dp851
g13
Nsg14
g839
sg16
S'fragments'
p852
sbasg9
(lp853
g847
ag850
ag600
asg33
I2
sg34
S'This control is sent by the receiver of commands and handled by the\nsender of commands. This sends the set of commands that will\ndefinitely be completed by this peer to the sender. This excludes\ncommands known by the receiver to be considered confirmed or complete\nat the sender.\n\nThis control must be sent if the partner requests the set of confirmed\ncommands using the session.flush control with the confirmed flag set.\n\nThis control may be sent spontaneously. One reason for separating\nconfirmation from completion is for large persistent messages, where\nthe receipt (and storage to a durable store) of part of the message\nwill result in less data needing to be replayed in the case of\ntransport failure during transmission.\n\nA simple implementation of an AMQP client or server may be implemented\nto take no action on receipt of session.confirmed controls, and take\naction only when receiving session.completed controls.\n\nA simple implementation of an AMQP client or server may be implemented\nsuch that it never spontaneously sends session.confirmed and that when\nrequested for the set of confirmed commands (via the session.flush\ncontrol) it responds with the same set of commands as it would to when\nthe set of completed commands was requested (trivially all completed\ncommands are confirmed).\n\n  commands -- entirely confirmed commands\n\n  fragments -- partially confirmed commands'
p854
sg36
I0
stp855
a(S'SessionCompleted'
(g584
t(dp856
g4
I522
sg5
S'session_completed'
p857
sg7
(lp858
(iqpid.ops
Field
p859
(dp860
g13
Nsg14
g109
sg16
S'commands'
p861
sba(iqpid.ops
Field
p862
(dp863
g13
I00
sg14
S'bit'
p864
sg16
S'timely_reply'
p865
sbasg9
(lp866
g859
ag862
ag600
asg33
I2
sg34
S'This control is sent by the receiver of commands, and handled by the\nsender of commands. It informs the sender of all commands completed by\nthe receiver. This excludes commands known by the receiver to be\nconsidered complete at the sender.\n\n  commands -- completed commands\n\n    The ids of all completed commands. This excludes commands known by\n    the receiver to be considered complete at the sender.\n\n  timely_reply -- None\n\n    If set, the sender is no longer free to delay the known-completed\n    reply.'
p867
sg36
I0
stp868
a(S'SessionKnownCompleted'
(g584
t(dp869
g4
I523
sg5
S'session_known_completed'
p870
sg7
(lp871
(iqpid.ops
Field
p872
(dp873
g13
Nsg14
g109
sg16
S'commands'
p874
sbasg9
(lp875
g872
ag600
asg33
I2
sg34
S'This control is sent by the sender of commands, and handled by the\nreceiver of commands. It is sent in reply to one or more completed\ncontrols from the receiver. It informs the receiver that commands are\nknown to be completed by the sender.\n\n  commands -- commands known to be complete\n\n    The set of completed commands for one or more session.completed\n    controls.'
p876
sg36
I0
stp877
a(S'SessionFlush'
(g584
t(dp878
g4
I524
sg5
S'session_flush'
p879
sg7
(lp880
(iqpid.ops
Field
p881
(dp882
g13
I00
sg14
S'bit'
p883
sg16
S'expected'
p884
sba(iqpid.ops
Field
p885
(dp886
g13
I00
sg14
S'bit'
p887
sg16
S'confirmed'
p888
sba(iqpid.ops
Field
p889
(dp890
g13
I00
sg14
S'bit'
p891
sg16
S'completed'
p892
sbasg9
(lp893
g881
ag885
ag889
ag600
asg33
I2
sg34
S'This control is sent by the sender of commands and handled by the\nreceiver of commands. It requests that the receiver produce the\nindicated command sets. The receiver should issue the indicated sets\nat the earliest possible opportunity.\n\n  expected -- request notification of expected commands\n\n  confirmed -- request notification of confirmed commands\n\n  completed -- request notification of completed commands'
p894
sg36
I0
stp895
a(S'SessionGap'
(g584
t(dp896
g4
I525
sg5
S'session_gap'
p897
sg7
(lp898
(iqpid.ops
Field
p899
(dp900
g13
Nsg14
g109
sg16
S'commands'
p901
sbasg9
(lp902
g899
ag600
asg33
I2
sg34
S'This control is sent by the sender of commands and handled by the\nreceiver of commands. It sends command ranges for which there will be\nno further data forthcoming. The receiver should proceed with the next\navailable commands that arrive after the gap.\n\n  commands -- None\n\n    The set of command-ids that are contained in this gap.'
p903
sg36
I0
stp904
a(S'Acquired'
(cqpid.ops
Compound
p905
t(dp906
g4
I1028
sg5
S'acquired'
p907
sg7
(lp908
(iqpid.ops
Field
p909
(dp910
g13
Nsg14
g109
sg16
S'transfers'
p911
sbasg9
(lp912
g909
asg33
I2
sg34
S'Identifies a set of previously transferred messages that have now been\nacquired.\n\n  transfers -- None\n\n    Indicates the acquired messages.'
p913
sg36
I4
stp914
a(S'MessageResumeResult'
(g905
t(dp915
g4
I1029
sg5
S'message_resume_result'
p916
sg7
(lp917
(iqpid.ops
Field
p918
(dp919
g13
Nsg14
S'uint64'
p920
sg16
S'offset'
p921
sbasg9
(lp922
g918
asg33
I2
sg34
S'\n\n  offset -- None\n\n    Indicates the amount of data already transferred.'
p923
sg36
I4
stp924
a(S'GetTimeoutResult'
(g905
t(dp925
g4
I1538
sg5
S'get_timeout_result'
p926
sg7
(lp927
(iqpid.ops
Field
p928
(dp929
g13
Nsg14
S'uint32'
p930
sg16
S'timeout'
p931
sbasg9
(lp932
g928
asg33
I2
sg34
S'Returns the value of the timeout last specified through set-timeout.\n\n  timeout -- The current transaction timeout value\n\n    The current transaction timeout value in seconds.'
p933
sg36
I4
stp934
a(S'RecoverResult'
(g905
t(dp935
g4
I1539
sg5
S'recover_result'
p936
sg7
(lp937
(iqpid.ops
Field
p938
(dp939
g13
Nsg14
S'array'
p940
sg16
S'in_doubt'
p941
sbasg9
(lp942
g938
asg33
I2
sg34
S'Returns to the client a table with single item that is a sequence of\ntransaction xids that are in a prepared or heuristically completed\nstate.\n\n  in_doubt -- array of xids to be recovered\n\n    Array containing the xids to be recovered (xids that are in a\n    prepared or heuristically completed state).'
p943
sg36
I4
stp944
a(S'ExchangeQueryResult'
(g905
t(dp945
g4
I1793
sg5
S'exchange_query_result'
p946
sg7
(lp947
(iqpid.ops
Field
p948
(dp949
g13
Nsg14
S'str8'
p950
sg16
S'type'
p951
sba(iqpid.ops
Field
p952
(dp953
g13
I00
sg14
S'bit'
p954
sg16
S'durable'
p955
sba(iqpid.ops
Field
p956
(dp957
g13
I00
sg14
S'bit'
p958
sg16
S'not_found'
p959
sba(iqpid.ops
Field
p960
(dp961
g13
Nsg14
S'map'
p962
sg16
S'arguments'
p963
sbasg9
(lp964
g948
ag952
ag956
ag960
asg33
I2
sg34
S'This is sent in response to a query request and conveys information on\na particular exchange.\n\n  type -- indicate the exchange type\n\n    The type of the exchange. Will be empty if the exchange is not\n    found.\n\n  durable -- indicate the durability\n\n    The durability of the exchange, i.e. if set the exchange is\n    durable. Will not be set if the exchange is not found.\n\n  not_found -- indicate an unknown exchange\n\n    If set, the exchange for which information was requested is not\n    known.\n\n  arguments -- other unspecified exchange properties\n\n    A set of properties of the exchange whose syntax and semantics\n    depends on the server implementation. Will be empty if the\n    exchange is not found.'
p965
sg36
I4
stp966
a(S'ExchangeBoundResult'
(g905
t(dp967
g4
I1794
sg5
S'exchange_bound_result'
p968
sg7
(lp969
(iqpid.ops
Field
p970
(dp971
g13
I00
sg14
S'bit'
p972
sg16
S'exchange_not_found'
p973
sba(iqpid.ops
Field
p974
(dp975
g13
I00
sg14
S'bit'
p976
sg16
S'queue_not_found'
p977
sba(iqpid.ops
Field
p978
(dp979
g13
I00
sg14
S'bit'
p980
sg16
S'queue_not_matched'
p981
sba(iqpid.ops
Field
p982
(dp983
g13
I00
sg14
S'bit'
p984
sg16
S'key_not_matched'
p985
sba(iqpid.ops
Field
p986
(dp987
g13
I00
sg14
S'bit'
p988
sg16
S'args_not_matched'
p989
sbasg9
(lp990
g970
ag974
ag978
ag982
ag986
asg33
I2
sg34
S'\n\n  exchange_not_found -- indicate an unknown exchange\n\n    If set, the exchange for which information was requested is not\n    known.\n\n  queue_not_found -- indicate an unknown queue\n\n    If set, the queue specified is not known.\n\n  queue_not_matched -- indicate no matching queue\n\n    A bit which if set indicates that no binding was found from the\n    specified exchange to the specified queue.\n\n  key_not_matched -- indicate no matching binding-key\n\n    A bit which if set indicates that no binding was found from the\n    specified exchange with the specified binding-key.\n\n  args_not_matched -- indicate no matching arguments\n\n    A bit which if set indicates that no binding was found from the\n    specified exchange with the specified arguments.'
p991
sg36
I4
stp992
a(S'QueueQueryResult'
(g905
t(dp993
g4
I2049
sg5
S'queue_query_result'
p994
sg7
(lp995
(iqpid.ops
Field
p996
(dp997
g13
Nsg14
g173
sg16
S'queue'
p998
sba(iqpid.ops
Field
p999
(dp1000
g13
Nsg14
g405
sg16
S'alternate_exchange'
p1001
sba(iqpid.ops
Field
p1002
(dp1003
g13
I00
sg14
S'bit'
p1004
sg16
S'durable'
p1005
sba(iqpid.ops
Field
p1006
(dp1007
g13
I00
sg14
S'bit'
p1008
sg16
S'exclusive'
p1009
sba(iqpid.ops
Field
p1010
(dp1011
g13
I00
sg14
S'bit'
p1012
sg16
S'auto_delete'
p1013
sba(iqpid.ops
Field
p1014
(dp1015
g13
Nsg14
S'map'
p1016
sg16
S'arguments'
p1017
sba(iqpid.ops
Field
p1018
(dp1019
g13
Nsg14
S'uint32'
p1020
sg16
S'message_count'
p1021
sba(iqpid.ops
Field
p1022
(dp1023
g13
Nsg14
S'uint32'
p1024
sg16
S'subscriber_count'
p1025
sbasg9
(lp1026
g996
ag999
ag1002
ag1006
ag1010
ag1014
ag1018
ag1022
asg33
I2
sg34
S'This is sent in response to queue.query, and conveys the requested\ninformation about a queue. If no queue with the specified name exists\nthen none of the fields within the returned result struct will be\npopulated.\n\n  queue -- None\n\n    Reports the name of the queue.\n\n  alternate_exchange -- None\n\n  durable -- None\n\n  exclusive -- None\n\n  auto_delete -- None\n\n  arguments -- None\n\n  message_count -- number of messages in queue\n\n    Reports the number of messages in the queue.\n\n  subscriber_count -- number of subscribers\n\n    Reports the number of subscribers for the queue.'
p1027
sg36
I4
stp1028
a(S'Header'
(g905
t(dp1029
g4
Nsg5
S'header'
p1030
sg7
(lp1031
(iqpid.ops
Field
p1032
(dp1033
g13
I00
sg14
S'bit'
p1034
sg16
S'sync'
p1035
sbasg9
(lp1036
g1032
asg33
I1
sg34
S'The session header appears on commands after the class and command id,\nbut prior to command arguments.\n\n  sync -- request notification of completion\n\n    Request notification of completion for this command.'
p1037
sg36
I1
stp1038
a(S'CommandFragment'
(g905
t(dp1039
g4
Nsg5
S'command_fragment'
p1040
sg7
(lp1041
(iqpid.ops
Field
p1042
(dp1043
g13
Nsg14
S'sequence_no'
p1044
sg16
S'command_id'
p1045
sba(iqpid.ops
Field
p1046
(dp1047
g13
Nsg14
S'byte_ranges'
p1048
sg16
S'byte_ranges'
p1049
sbasg9
(lp1050
g1042
ag1046
asg33
I0
sg34
S'\n\n  command_id -- None\n\n  byte_ranges -- None'
p1051
sg36
I0
stp1052
a(S'DeliveryProperties'
(g905
t(dp1053
g4
I1025
sg5
S'delivery_properties'
p1054
sg7
(lp1055
(iqpid.ops
Field
p1056
(dp1057
g13
I00
sg14
S'bit'
p1058
sg16
S'discard_unroutable'
p1059
sba(iqpid.ops
Field
p1060
(dp1061
g13
I00
sg14
S'bit'
p1062
sg16
S'immediate'
p1063
sba(iqpid.ops
Field
p1064
(dp1065
g13
I00
sg14
S'bit'
p1066
sg16
S'redelivered'
p1067
sba(iqpid.ops
Field
p1068
(dp1069
g13
Nsg14
S'uint8'
p1070
sg16
S'priority'
p1071
sba(iqpid.ops
Field
p1072
(dp1073
g13
Nsg14
S'uint8'
p1074
sg16
S'delivery_mode'
p1075
sba(iqpid.ops
Field
p1076
(dp1077
g13
Nsg14
S'uint64'
p1078
sg16
S'ttl'
p1079
sba(iqpid.ops
Field
p1080
(dp1081
g13
Nsg14
S'datetime'
p1082
sg16
S'timestamp'
p1083
sba(iqpid.ops
Field
p1084
(dp1085
g13
Nsg14
S'datetime'
p1086
sg16
S'expiration'
p1087
sba(iqpid.ops
Field
p1088
(dp1089
g13
Nsg14
g405
sg16
S'exchange'
p1090
sba(iqpid.ops
Field
p1091
(dp1092
g13
Nsg14
S'str8'
p1093
sg16
S'routing_key'
p1094
sba(iqpid.ops
Field
p1095
(dp1096
g13
Nsg14
g162
sg16
S'resume_id'
p1097
sba(iqpid.ops
Field
p1098
(dp1099
g13
Nsg14
S'uint64'
p1100
sg16
S'resume_ttl'
p1101
sbasg9
(lp1102
g1056
ag1060
ag1064
ag1068
ag1072
ag1076
ag1080
ag1084
ag1088
ag1091
ag1095
ag1098
asg33
I2
sg34
S'\n\n  discard_unroutable -- controls discard of unroutable messages\n\n    If set on a message that is not routable the broker can discard\n    it. If not set, an unroutable message should be handled by reject\n    when accept-mode is explicit; or by routing to the alternate-\n    exchange if defined when accept-mode is none.\n\n  immediate -- Consider message unroutable if it cannot be         processed immediately\n\n    If the immediate flag is set to true on a message transferred to a\n    Server, then the message should be considered unroutable (and not\n    delivered to any queues) if, for any queue that it is to be routed\n    to according to the standard routing behavior, there is not a\n    subscription on that queue able to receive the message. The\n    treatment of unroutable messages is dependent on the value of the\n    discard-unroutable flag.\n\n    The immediate flag is ignored on transferred to a Client.\n\n  redelivered -- redelivery flag\n\n    This boolean flag indicates that the message may have been\n    previously delivered to this or another client.\n\n    If the redelivered flag is set on transfer to a Server, then any\n    delivery of the message from that Server to a Client must also\n    have the redelivered flag set to true.\n\n  priority -- message priority, 0 to 9\n\n    Message priority, which can be between 0 and 9. Messages with\n    higher priorities may be delivered before those with lower\n    priorities.\n\n  delivery_mode -- message persistence requirement\n\n    The delivery mode may be non-persistent or persistent.\n\n  ttl -- time to live in ms\n\n    Duration in milliseconds for which the message should be\n    considered "live". If this is set then a message expiration time\n    will be computed based on the current time plus this value.\n    Messages that live longer than their expiration time will be\n    discarded (or dead lettered).\n\n  timestamp -- message timestamp\n\n    The timestamp is set by the broker on arrival of the message.\n\n  expiration -- message expiration time\n\n    The expiration header assigned by the broker. After receiving the\n    message the broker sets expiration to the sum of the ttl specified\n    in the publish command and the current time. (ttl=expiration -\n    timestamp)\n\n  exchange -- originating exchange\n\n    Identifies the exchange specified in the destination field of the\n    message.transfer used to publish the message. This MUST be set by\n    the broker upon receipt of a message.\n\n  routing_key -- message routing key\n\n    The value of the key determines to which queue the exchange will\n    send the message. The way in which keys are used to make this\n    routing decision depends on the type of exchange to which the\n    message is sent. For example, a direct exchange will route a\n    message to a queue if that queue is bound to the exchange with a\n    binding-key identical to the routing-key of the message.\n\n  resume_id -- global id for message transfer\n\n    When a resume-id is provided the recipient MAY use it to retain\n    message data should the session expire while the message transfer\n    is still incomplete.\n\n  resume_ttl -- ttl in ms for interrupted message data\n\n    When a resume-ttl is provided the recipient MAY use it has a\n    guideline for how long to retain the partially complete data when\n    a resume-id is specified. If no resume-id is specified then this\n    value should be ignored.'
p1103
sg36
I4
stp1104
a(S'FragmentProperties'
(g905
t(dp1105
g4
I1026
sg5
S'fragment_properties'
p1106
sg7
(lp1107
(iqpid.ops
Field
p1108
(dp1109
g13
I00
sg14
S'bit'
p1110
sg16
S'first'
p1111
sba(iqpid.ops
Field
p1112
(dp1113
g13
I00
sg14
S'bit'
p1114
sg16
S'last'
p1115
sba(iqpid.ops
Field
p1116
(dp1117
g13
Nsg14
S'uint64'
p1118
sg16
S'fragment_size'
p1119
sbasg9
(lp1120
g1108
ag1112
ag1116
asg33
I2
sg34
S'These properties permit the transfer of message fragments. These may\nbe used in conjunction with byte level flow control to limit the rate\nat which large messages are received. Only the first fragment carries\nthe delivery-properties and message-properties. Syntactically each\nfragment appears as a complete message to the lower layers of the\nprotocol, however the model layer is required to treat all the\nfragments as a single message. For example all fragments must be\ndelivered to the same client. In pre-acquired mode, no message\nfragments can be delivered by the broker until the entire message has\nbeen received.\n\n  first -- None\n\n    True if this fragment contains the start of the message, false\n    otherwise.\n\n  last -- None\n\n    True if this fragment contains the end of the message, false\n    otherwise.\n\n  fragment_size -- None\n\n    This field may optionally contain the size of the fragment.'
p1121
sg36
I4
stp1122
a(S'ReplyTo'
(g905
t(dp1123
g4
Nsg5
S'reply_to'
p1124
sg7
(lp1125
(iqpid.ops
Field
p1126
(dp1127
g13
Nsg14
g405
sg16
S'exchange'
p1128
sba(iqpid.ops
Field
p1129
(dp1130
g13
Nsg14
S'str8'
p1131
sg16
S'routing_key'
p1132
sbasg9
(lp1133
g1126
ag1129
asg33
I2
sg34
S'The reply-to domain provides a simple address structure for replying\nto to a message to a destination within the same virtual-host.\n\n  exchange -- the name of the exchange to reply to\n\n  routing_key -- the routing-key to use when replying'
p1134
sg36
I2
stp1135
a(S'MessageProperties'
(g905
t(dp1136
g4
I1027
sg5
S'message_properties'
p1137
sg7
(lp1138
(iqpid.ops
Field
p1139
(dp1140
g13
Nsg14
S'uint64'
p1141
sg16
S'content_length'
p1142
sba(iqpid.ops
Field
p1143
(dp1144
g13
Nsg14
S'uuid'
p1145
sg16
S'message_id'
p1146
sba(iqpid.ops
Field
p1147
(dp1148
g13
Nsg14
S'vbin16'
p1149
sg16
S'correlation_id'
p1150
sba(iqpid.ops
Field
p1151
(dp1152
g13
Nsg14
S'reply_to'
p1153
sg16
S'reply_to'
p1154
sba(iqpid.ops
Field
p1155
(dp1156
g13
Nsg14
S'str8'
p1157
sg16
S'content_type'
p1158
sba(iqpid.ops
Field
p1159
(dp1160
g13
Nsg14
S'str8'
p1161
sg16
S'content_encoding'
p1162
sba(iqpid.ops
Field
p1163
(dp1164
g13
Nsg14
S'vbin16'
p1165
sg16
S'user_id'
p1166
sba(iqpid.ops
Field
p1167
(dp1168
g13
Nsg14
S'vbin16'
p1169
sg16
S'app_id'
p1170
sba(iqpid.ops
Field
p1171
(dp1172
g13
Nsg14
S'map'
p1173
sg16
S'application_headers'
p1174
sbasg9
(lp1175
g1139
ag1143
ag1147
ag1151
ag1155
ag1159
ag1163
ag1167
ag1171
asg33
I2
sg34
S'\n\n  content_length -- length of the body segment in bytes\n\n    The length of the body segment in bytes.\n\n  message_id -- application message identifier\n\n    Message-id is an optional property of UUID type which uniquely\n    identifies a message within the message system. The message\n    producer is usually responsible for setting the message-id. The\n    server MAY discard a message as a duplicate if the value of the\n    message-id matches that of a previously received message.\n    Duplicate messages MUST still be accepted if transferred with an\n    accept-mode of "explicit".\n\n  correlation_id -- application correlation identifier\n\n    This is a client-specific id that may be used to mark or identify\n    messages between clients. The server ignores this field.\n\n  reply_to -- destination to reply to\n\n    The destination of any message that is sent in reply to this\n    message.\n\n  content_type -- MIME content type\n\n    The RFC-2046 MIME type for the message content (such as\n    "text/plain"). This is set by the originating client.\n\n  content_encoding -- MIME content encoding\n\n    The encoding for character-based message content. This is set by\n    the originating client. Examples include UTF-8 and ISO-8859-15.\n\n  user_id -- creating user id\n\n    The identity of the user responsible for producing the message.\n    The client sets this value, and it is authenticated by the broker.\n\n  app_id -- creating application id\n\n    The identity of the client application responsible for producing\n    the message.\n\n  application_headers -- application specific headers table\n\n    This is a collection of user-defined headers or properties which\n    may be set by the producing client and retrieved by the consuming\n    client.'
p1176
sg36
I4
stp1177
a(S'XaResult'
(g905
t(dp1178
g4
I1537
sg5
S'xa_result'
p1179
sg7
(lp1180
(iqpid.ops
Field
p1181
(dp1182
g13
Nsg14
S'uint16'
p1183
sg16
S'status'
p1184
sbasg9
(lp1185
g1181
asg33
I2
sg34
S'\n\n  status -- None'
p1186
sg36
I4
stp1187
a(S'Xid'
(g905
t(dp1188
g4
I1540
sg5
S'xid'
p1189
sg7
(lp1190
(iqpid.ops
Field
p1191
(dp1192
g13
Nsg14
S'uint32'
p1193
sg16
S'format'
p1194
sba(iqpid.ops
Field
p1195
(dp1196
g13
Nsg14
S'vbin8'
p1197
sg16
S'global_id'
p1198
sba(iqpid.ops
Field
p1199
(dp1200
g13
Nsg14
S'vbin8'
p1201
sg16
S'branch_id'
p1202
sbasg9
(lp1203
g1191
ag1195
ag1199
asg33
I2
sg34
S'An xid uniquely identifies a transaction branch.\n\n  format -- implementation specific format code\n\n  global_id -- global transaction id\n\n  branch_id -- branch qualifier'
p1204
sg36
I4
stp1205
a(S'close_code'
p1206
(cqpid.ops
Enum
p1207
t(dp1208
S'invalid_path'
p1209
I402
sS'normal'
p1210
I200
sS'framing_error'
p1211
I501
sS'connection_forced'
p1212
I320
sS'VALUES'
p1213
(lp1214
I200
aI320
aI402
aI501
asS'TYPE'
p1215
S'uint16'
p1216
sg34
S'\n\n  normal -- None\n\n    The connection closed normally.\n\n  connection_forced -- None\n\n    An operator intervened to close the connection for some reason.\n    The client may retry at some later date.\n\n  invalid_path -- None\n\n    The client tried to work with an unknown virtual host.\n\n  framing_error -- None\n\n    A valid frame header cannot be formed from the incoming byte\n    stream.'
p1217
sg5
g1206
stp1218
a(S'detach_code'
p1219
(g1207
t(dp1220
g5
g1219
sS'normal'
p1221
I0
sS'unknown_ids'
p1222
I4
sg1213
(lp1223
I0
aI1
aI2
aI3
aI4
asS'transport_busy'
p1224
I2
sS'session_busy'
p1225
I1
sS'not_attached'
p1226
I3
sg1215
S'uint8'
p1227
sg34
S'\n\n  normal -- None\n\n    The session was detached by request.\n\n  session_busy -- None\n\n    The session is currently attached to another transport.\n\n  transport_busy -- None\n\n    The transport is currently attached to another session.\n\n  not_attached -- None\n\n    The transport is not currently attached to any session.\n\n  unknown_ids -- None\n\n    Command data was received prior to any use of the command-point\n    control.'
p1228
stp1229
a(S'error_code'
p1230
(g1207
t(dp1231
S'resource_deleted'
p1232
I408
sS'resource_limit_exceeded'
p1233
I506
sS'illegal_argument'
p1234
I531
sg5
g1230
sS'invalid_argument'
p1235
I542
sS'internal_error'
p1236
I541
sS'command_invalid'
p1237
I503
sS'precondition_failed'
p1238
I406
sS'illegal_state'
p1239
I409
sS'unauthorized_access'
p1240
I403
sS'not_implemented'
p1241
I540
sg1213
(lp1242
I403
aI404
aI405
aI406
aI408
aI409
aI503
aI506
aI530
aI531
aI540
aI541
aI542
asS'not_allowed'
p1243
I530
sS'resource_locked'
p1244
I405
sS'not_found'
p1245
I404
sg1215
S'uint16'
p1246
sg34
S'\n\n  unauthorized_access -- None\n\n    The client attempted to work with a server entity to which it has\n    no access due to security settings.\n\n  not_found -- None\n\n    The client attempted to work with a server entity that does not\n    exist.\n\n  resource_locked -- None\n\n    The client attempted to work with a server entity to which it has\n    no access because another client is working with it.\n\n  precondition_failed -- None\n\n    The client requested a command that was not allowed because some\n    precondition failed.\n\n  resource_deleted -- None\n\n    A server entity the client is working with has been deleted.\n\n  illegal_state -- None\n\n    The peer sent a command that is not permitted in the current state\n    of the session.\n\n  command_invalid -- None\n\n    The command segments could not be decoded.\n\n  resource_limit_exceeded -- None\n\n    The client exceeded its resource allocation.\n\n  not_allowed -- None\n\n    The peer tried to use a command a manner that is inconsistent with\n    the rules described in the specification.\n\n  illegal_argument -- None\n\n    The command argument is malformed, i.e. it does not fall within\n    the specified domain. The illegal-argument exception can be raised\n    on execution of any command which has domain valued fields.\n\n  not_implemented -- None\n\n    The peer tried to use functionality that is not implemented in its\n    partner.\n\n  internal_error -- None\n\n    The peer could not complete the command because of an internal\n    error. The peer may require intervention by an operator in order\n    to resume normal operations.\n\n  invalid_argument -- None\n\n    An invalid argument was passed to a command, and the operation\n    could not proceed. An invalid argument is not illegal (see\n    illegal-argument), i.e. it matches the domain definition; however\n    the particular value is invalid in this context.'
p1247
stp1248
a(S'accept_mode'
p1249
(g1207
t(dp1250
S'none'
p1251
I1
sg5
g1249
sS'explicit'
p1252
I0
sg1213
(lp1253
I0
aI1
asg1215
S'uint8'
p1254
sg34
S'\n\n  explicit -- None\n\n    Successful transfer is signaled by message.accept. An acquired\n    message (whether acquisition was implicit as in pre-acquired mode\n    or explicit as in not-acquired mode) is not considered transferred\n    until a message.accept that includes the transfer command is\n    received.\n\n  none -- None\n\n    Successful transfer is assumed when accept-mode is "pre-acquired".\n    Messages transferred with an accept-mode of "not-acquired" cannot\n    be acquired when accept-mode is "none".'
p1255
stp1256
a(S'acquire_mode'
p1257
(g1207
t(dp1258
S'not_acquired'
p1259
I1
sg5
g1257
sS'pre_acquired'
p1260
I0
sg1213
(lp1261
I0
aI1
asg1215
S'uint8'
p1262
sg34
S'\n\n  pre_acquired -- None\n\n    the message is acquired when the transfer starts\n\n  not_acquired -- None\n\n    the message is not acquired when it arrives, and must be\n    explicitly acquired by the recipient'
p1263
stp1264
a(S'reject_code'
p1265
(g1207
t(dp1266
g5
g1265
sS'unroutable'
p1267
I1
sS'immediate'
p1268
I2
sg1213
(lp1269
I0
aI1
aI2
asS'unspecified'
p1270
I0
sg1215
S'uint16'
p1271
sg34
S'\n\n  unspecified -- None\n\n    Rejected for an unspecified reason.\n\n  unroutable -- None\n\n    Delivery was attempted but there were no queues which the message\n    could be routed to.\n\n  immediate -- None\n\n    The rejected message had the immediate flag set to true, but at\n    the time of the transfer at least one of the queues to which it\n    was to be routed did not have any subscriber able to take the\n    message.'
p1272
stp1273
a(S'delivery_mode'
p1274
(g1207
t(dp1275
g5
g1274
sS'persistent'
p1276
I2
sg1213
(lp1277
I1
aI2
asS'non_persistent'
p1278
I1
sg1215
S'uint8'
p1279
sg34
S'\n\n  non_persistent -- None\n\n    A non-persistent message may be lost in event of a failure, but\n    the nature of the communication is such that an occasional message\n    loss is tolerable. This is the lowest overhead mode. Non-\n    persistent messages are delivered at most once only.\n\n  persistent -- None\n\n    A persistent message is one which must be stored on a persistent\n    medium (usually hard drive) at every stage of delivery so that it\n    will not be lost in event of failure (other than of the medium\n    itself). This is normally accomplished with some additional\n    overhead. A persistent message may be delivered more than once if\n    there is uncertainty about the state of its delivery after a\n    failure and recovery.'
p1280
stp1281
a(S'delivery_priority'
p1282
(g1207
t(dp1283
S'lowest'
p1284
I0
sS'lower'
p1285
I1
sS'medium'
p1286
I4
sg5
g1282
sS'above_average'
p1287
I5
sS'very_high'
p1288
I8
sS'high'
p1289
I6
sg1213
(lp1290
I0
aI1
aI2
aI3
aI4
aI5
aI6
aI7
aI8
aI9
asS'low'
p1291
I2
sS'below_average'
p1292
I3
sS'highest'
p1293
I9
sg1215
S'uint8'
p1294
sg34
S'\n\n  lowest -- None\n\n    Lowest possible priority message.\n\n  lower -- None\n\n    Very low priority message\n\n  low -- None\n\n    Low priority message.\n\n  below_average -- None\n\n    Below average priority message.\n\n  medium -- None\n\n    Medium priority message.\n\n  above_average -- None\n\n    Above average priority message\n\n  high -- None\n\n    High priority message\n\n  higher -- None\n\n    Higher priority message\n\n  very_high -- None\n\n    Very high priority message.\n\n  highest -- None\n\n    Highest possible priority message.'
p1295
sS'higher'
p1296
I7
stp1297
a(S'flow_mode'
p1298
(g1207
t(dp1299
g5
g1298
sS'credit'
p1300
I0
sS'window'
p1301
I1
sg1213
(lp1302
I0
aI1
asg1215
S'uint8'
p1303
sg34
S'\n\n  credit -- None\n\n    Credit based flow control.\n\n  window -- None\n\n    Window based flow control.'
p1304
stp1305
a(S'credit_unit'
p1306
(g1207
t(dp1307
g5
g1306
sg34
S'\n\n  message -- None\n\n    Indicates a value specified in messages.\n\n  byte -- None\n\n    Indicates a value specified in bytes.'
p1308
sg1213
(lp1309
I0
aI1
asS'byte'
p1310
I1
sg1215
S'uint8'
p1311
sS'message'
p1312
I0
stp1313
a(S'xa_status'
p1314
(g1207
t(dp1315
S'xa_heurmix'
p1316
I6
sS'xa_heurrb'
p1317
I5
sS'xa_rbtimeout'
p1318
I2
sS'xa_ok'
p1319
I0
sS'xa_rbrollback'
p1320
I1
sS'xa_heurcom'
p1321
I4
sS'xa_rdonly'
p1322
I7
sS'xa_heurhaz'
p1323
I3
sg1213
(lp1324
I0
aI1
aI2
aI3
aI4
aI5
aI6
aI7
asg1215
S'uint16'
p1325
sg34
S'\n\n  xa_ok -- None\n\n    Normal execution completion (no error).\n\n  xa_rbrollback -- None\n\n    The rollback was caused for an unspecified reason.\n\n  xa_rbtimeout -- None\n\n    A transaction branch took too long.\n\n  xa_heurhaz -- None\n\n    The transaction branch may have been heuristically completed.\n\n  xa_heurcom -- None\n\n    The transaction branch has been heuristically committed.\n\n  xa_heurrb -- None\n\n    The transaction branch has been heuristically rolled back.\n\n  xa_heurmix -- None\n\n    The transaction branch has been heuristically committed and rolled\n    back.\n\n  xa_rdonly -- None\n\n    The transaction branch was read-only and has been committed.'
p1326
sg5
g1314
stp1327
a(S'segment_type'
p1328
(g1207
t(dp1329
S'control'
p1330
I0
sS'body'
p1331
I3
sg5
g1328
sS'header'
p1332
I2
sS'command'
p1333
I1
sg1213
(lp1334
I0
aI1
aI2
aI3
asg1215
S'uint8'
p1335
sg34
S'\n\n  control -- None\n\n    The frame type indicator for Control segments (see ).\n\n  command -- None\n\n    The frame type indicator for Command segments (see ).\n\n  header -- None\n\n    The frame type indicator for Header segments (see ).\n\n  body -- None\n\n    The frame type indicator for Body segments (see ).'
p1336
stp1337
a(S'track'
p1338
(g1207
t(dp1339
S'control'
p1340
I0
sg5
g1338
sS'command'
p1341
I1
sg1213
(lp1342
I0
aI1
asg1215
S'uint8'
p1343
sg34
S'\n\n  control -- None\n\n    The track used for all controls. All controls defined in this\n    specification MUST be sent on track 0.\n\n  command -- None\n\n    The track used for all commands. All commands defined in this\n    specification MUST be sent on track 1.'
p1344
stp1345
a(S'Bin8'
(cqpid.ops
Primitive
p1346
t(dp1347
g4
I0
sg34
S'The bin8 type consists of exactly one octet of opaque binary data.\n\n1 OCTET +----------+ | bin8 | +----------+\n\nbin8 = OCTET'
p1348
sg5
S'bin8'
p1349
stp1350
a(S'Int8'
(g1346
t(dp1351
g4
I1
sg34
S"The int8 type is a signed integral value encoded using an 8-bit two's\ncomplement representation.\n\n1 OCTET +----------+ | int8 | +----------+\n\nint8 = OCTET"
p1352
sg5
S'int8'
p1353
stp1354
a(S'Uint8'
(g1346
t(dp1355
g4
I2
sg34
S'The uint8 type is an 8-bit unsigned integral value.\n\n1 OCTET +---------+ | uint8 | +---------+\n\nuint8 = OCTET'
p1356
sg5
S'uint8'
p1357
stp1358
a(S'Char'
(g1346
t(dp1359
g4
I4
sg34
S'The char type encodes a single character from the iso-8859-15\ncharacter set.\n\n1 OCTET +----------+ | char | +----------+\n\nchar = OCTET'
p1360
sg5
S'char'
p1361
stp1362
a(S'Boolean'
(g1346
t(dp1363
g4
I8
sg34
S'The boolean type is a single octet that encodes a true or false value.\nIf the octet is zero, then the boolean is false. Any other value\nrepresents true.\n\n1 OCTET +---------+ | boolean | +---------+\n\nboolean = OCTET'
p1364
sg5
S'boolean'
p1365
stp1366
a(S'Bin16'
(g1346
t(dp1367
g4
I16
sg34
S'The bin16 type consists of two consecutive octets of opaque binary\ndata.\n\n1 OCTET 1 OCTET +-----------+-----------+ | octet-one | octet-two |\n+-----------+-----------+\n\nbin16 = 2 OCTET'
p1368
sg5
S'bin16'
p1369
stp1370
a(S'Int16'
(g1346
t(dp1371
g4
I17
sg34
S"The int16 type is a signed integral value encoded using a 16-bit two's\ncomplement representation in network byte order.\n\n1 OCTET 1 OCTET +-----------+----------+ | high-byte | low-byte |\n+-----------+----------+\n\nint16 = high-byte low-byte high-byte = OCTET low-byte = OCTET"
p1372
sg5
S'int16'
p1373
stp1374
a(S'Uint16'
(g1346
t(dp1375
g4
I18
sg34
S'The uint16 type is a 16-bit unsigned integral value encoded in network\nbyte order.\n\n1 OCTET 1 OCTET +-----------+----------+ | high-byte | low-byte |\n+-----------+----------+\n\nuint16 = high-byte low-byte high-byte = OCTET low-byte = OCTET'
p1376
sg5
S'uint16'
p1377
stp1378
a(S'Bin32'
(g1346
t(dp1379
g4
I32
sg34
S'The bin32 type consists of 4 consecutive octets of opaque binary data.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET\n+-----------+-----------+-------------+------------+ | octet-one |\noctet-two | octet-three | octet-four |\n+-----------+-----------+-------------+------------+\n\nbin32 = 4 OCTET'
p1380
sg5
S'bin32'
p1381
stp1382
a(S'Int32'
(g1346
t(dp1383
g4
I33
sg34
S"The int32 type is a signed integral value encoded using a 32-bit two's\ncomplement representation in network byte order.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET\n+-----------+------------+----------+----------+ | byte-four | byte-\nthree | byte-two | byte-one |\n+-----------+------------+----------+----------+ MSB LSB\n\nint32 = byte-four byte-three byte-two byte-one byte-four = OCTET ;\nmost significant byte (MSB) byte-three = OCTET byte-two = OCTET byte-\none = OCTET ; least significant byte (LSB)"
p1384
sg5
S'int32'
p1385
stp1386
a(S'Uint32'
(g1346
t(dp1387
g4
I34
sg34
S'The uint32 type is a 32-bit unsigned integral value encoded in network\nbyte order.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET\n+-----------+------------+----------+----------+ | byte-four | byte-\nthree | byte-two | byte-one |\n+-----------+------------+----------+----------+ MSB LSB\n\nuint32 = byte-four byte-three byte-two byte-one byte-four = OCTET ;\nmost significant byte (MSB) byte-three = OCTET byte-two = OCTET byte-\none = OCTET ; least significant byte (LSB)'
p1388
sg5
S'uint32'
p1389
stp1390
a(S'Float'
(g1346
t(dp1391
g4
I35
sg34
S'The float type encodes a single precision 32-bit floating point\nnumber. The format and operations are defined by the IEEE 754 standard\nfor 32-bit floating point numbers.\n\n4 OCTETs +-----------------------+ | float | +-----------------------+\nIEEE 754 32-bit float\n\nfloat = 4 OCTET ; IEEE 754 32-bit floating point number'
p1392
sg5
S'float'
p1393
stp1394
a(S'CharUtf32'
(g1346
t(dp1395
g4
I39
sg34
S'The char-utf32 type consists of a single unicode character in the\nUTF-32 encoding.\n\n4 OCTETs +------------------+ | char-utf32 | +------------------+\nUTF-32 character\n\nchar-utf32 = 4 OCTET ; single UTF-32 character'
p1396
sg5
S'char_utf32'
p1397
stp1398
a(S'SequenceNo'
(g1346
t(dp1399
g4
Nsg34
S'The sequence-no type encodes, in network byte order, a serial number\nas defined in RFC-1982. The arithmetic, operators, and ranges for\nnumbers of this type are defined by RFC-1982.\n\n4 OCTETs +------------------------+ | sequence-no |\n+------------------------+ RFC-1982 serial number\n\nsequence-no = 4 OCTET ; RFC-1982 serial number'
p1400
sg5
S'sequence_no'
p1401
stp1402
a(S'Bin64'
(g1346
t(dp1403
g4
I48
sg34
S'The bin64 type consists of eight consecutive octets of opaque binary\ndata.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET\n+-----------+-----------+-----+-------------+-------------+ | octet-\none | octet-two | ... | octet-seven | octet-eight |\n+-----------+-----------+-----+-------------+-------------+\n\nbin64 = 8 OCTET'
p1404
sg5
S'bin64'
p1405
stp1406
a(S'Int64'
(g1346
t(dp1407
g4
I49
sg34
S"The int64 type is a signed integral value encoded using a 64-bit two's\ncomplement representation in network byte order.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET\n+------------+------------+-----+----------+----------+ | byte-eight |\nbyte-seven | ... | byte-two | byte-one |\n+------------+------------+-----+----------+----------+ MSB LSB\n\nint64 = byte-eight byte-seven byte-six byte-five byte-four byte-three\nbyte-two byte-one byte-eight = 1 OCTET ; most significant byte (MSB)\nbyte-seven = 1 OCTET byte-six = 1 OCTET byte-five = 1 OCTET byte-four\n= 1 OCTET byte-three = 1 OCTET byte-two = 1 OCTET byte-one = 1 OCTET ;\nleast significant byte (LSB)"
p1408
sg5
S'int64'
p1409
stp1410
a(S'Uint64'
(g1346
t(dp1411
g4
I50
sg34
S'The uint64 type is a 64-bit unsigned integral value encoded in network\nbyte order.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET\n+------------+------------+-----+----------+----------+ | byte-eight |\nbyte-seven | ... | byte-two | byte-one |\n+------------+------------+-----+----------+----------+ MSB LSB\n\nuint64 = byte-eight byte-seven byte-six byte-five byte-four byte-three\nbyte-two byte-one byte-eight = 1 OCTET ; most significant byte (MSB)\nbyte-seven = 1 OCTET byte-six = 1 OCTET byte-five = 1 OCTET byte-four\n= 1 OCTET byte-three = 1 OCTET byte-two = 1 OCTET byte-one = 1 OCTET ;\nleast significant byte (LSB)'
p1412
sg5
S'uint64'
p1413
stp1414
a(S'Double'
(g1346
t(dp1415
g4
I51
sg34
S'The double type encodes a double precision 64-bit floating point\nnumber. The format and operations are defined by the IEEE 754 standard\nfor 64-bit double precision floating point numbers.\n\n8 OCTETs +-----------------------+ | double |\n+-----------------------+ IEEE 754 64-bit float\n\ndouble = 8 OCTET ; double precision IEEE 754 floating point number'
p1416
sg5
S'double'
p1417
stp1418
a(S'Datetime'
(g1346
t(dp1419
g4
I56
sg34
S'The datetime type encodes a date and time using the 64 bit POSIX\ntime_t format.\n\n8 OCTETs +---------------------+ | datetime | +---------------------+\nposix time_t format\n\ndatetime = 8 OCTET ; 64 bit posix time_t format'
p1420
sg5
S'datetime'
p1421
stp1422
a(S'Bin128'
(g1346
t(dp1423
g4
I64
sg34
S'The bin128 type consists of 16 consecutive octets of opaque binary\ndata.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET\n+-----------+-----------+-----+---------------+---------------+ |\noctet-one | octet-two | ... | octet-fifteen | octet-sixteen |\n+-----------+-----------+-----+---------------+---------------+\n\nbin128 = 16 OCTET'
p1424
sg5
S'bin128'
p1425
stp1426
a(S'Uuid'
(g1346
t(dp1427
g4
I72
sg34
S'The uuid type encodes a universally unique id as defined by RFC-4122.\nThe format and operations for this type can be found in section 4.1.2\nof RFC-4122.\n\n16 OCTETs +---------------+ | uuid | +---------------+ RFC-4122 UUID\n\nuuid = 16 OCTET ; RFC-4122 section 4.1.2'
p1428
sg5
S'uuid'
p1429
stp1430
a(S'Bin256'
(g1346
t(dp1431
g4
I80
sg34
S'The bin256 type consists of thirty two consecutive octets of opaque\nbinary data.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET\n+-----------+-----------+-----+------------------+------------------+\n| octet-one | octet-two | ... | octet-thirty-one | octet-thirty-two |\n+-----------+-----------+-----+------------------+------------------+\n\nbin256 = 32 OCTET'
p1432
sg5
S'bin256'
p1433
stp1434
a(S'Bin512'
(g1346
t(dp1435
g4
I96
sg34
S'The bin512 type consists of sixty four consecutive octets of opaque\nbinary data.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET\n+-----------+-----------+-----+-------------------+------------------+\n| octet-one | octet-two | ... | octet-sixty-three | octet-sixty-four |\n+-----------+-----------+-----+-------------------+------------------+\n\nbin512 = 64 OCTET'
p1436
sg5
S'bin512'
p1437
stp1438
a(S'Bin1024'
(g1346
t(dp1439
g4
I112
sg34
S'The bin1024 type consists of one hundred and twenty eight octets of\nopaque binary data.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET +-----------+-----------+-----+-------\n-----------------+------------------------+ | octet-one | octet-two |\n... | octet-one-twenty-seven | octet-one-twenty-eight | +-----------+-\n----------+-----+------------------------+------------------------+\n\nbin1024 = 128 OCTET'
p1440
sg5
S'bin1024'
p1441
stp1442
a(S'Vbin8'
(g1346
t(dp1443
g4
I128
sg34
S'The vbin8 type encodes up to 255 octets of opaque binary data. The\nnumber of octets is first encoded as an 8-bit unsigned integral value.\nThis is followed by the actual data.\n\n1 OCTET size OCTETs +---------+-------------+ | size | octets |\n+---------+-------------+ uint8\n\nvbin8 = size octets size = uint8 octets = 0*255 OCTET ; size OCTETs'
p1444
sg5
S'vbin8'
p1445
stp1446
a(S'Str8Latin'
(g1346
t(dp1447
g4
I132
sg34
S'The str8-latin type encodes up to 255 octets of iso-8859-15\ncharacters. The number of octets is first encoded as an 8-bit unsigned\nintegral value. This is followed by the actual characters.\n\n1 OCTET size OCTETs +---------+------------------------+ | size |\ncharacters | +---------+------------------------+ uint16 iso-8859-15\ncharacters\n\nstr8-latin = size characters size = uint8 characters = 0*255 OCTET ;\nsize OCTETs'
p1448
sg5
S'str8_latin'
p1449
stp1450
a(S'Str8'
(g1346
t(dp1451
g4
I133
sg34
S'The str8 type encodes up to 255 octets worth of UTF-8 unicode. The\nnumber of octets of unicode is first encoded as an 8-bit unsigned\nintegral value. This is followed by the actual UTF-8 unicode. Note\nthat the encoded size refers to the number of octets of unicode, not\nnecessarily the number of characters since the UTF-8 unicode may\ninclude multi-byte character sequences.\n\n1 OCTET size OCTETs +---------+--------------+ | size | utf8-unicode |\n+---------+--------------+ uint8\n\nstr8 = size utf8-unicode size = uint8 utf8-unicode = 0*255 OCTET ;\nsize OCTETs'
p1452
sg5
S'str8'
p1453
stp1454
a(S'Str8Utf16'
(g1346
t(dp1455
g4
I134
sg34
S'The str8-utf16 type encodes up to 255 octets worth of UTF-16 unicode.\nThe number of octets of unicode is first encoded as an 8-bit unsigned\nintegral value. This is followed by the actual UTF-16 unicode. Note\nthat the encoded size refers to the number of octets of unicode, not\nthe number of characters since the UTF-16 unicode will include at\nleast two octets per unicode character.\n\n1 OCTET size OCTETs +---------+---------------+ | size | utf16-unicode\n| +---------+---------------+ uint8\n\nstr8-utf16 = size utf16-unicode size = uint8 utf16-unicode = 0*255\nOCTET ; size OCTETs'
p1456
sg5
S'str8_utf16'
p1457
stp1458
a(S'Vbin16'
(g1346
t(dp1459
g4
I144
sg34
S'The vbin16 type encodes up to 65535 octets of opaque binary data. The\nnumber of octets is first encoded as a 16-bit unsigned integral value\nin network byte order. This is followed by the actual data.\n\n2 OCTETs size OCTETs +----------+-------------+ | size | octets |\n+----------+-------------+ uint16\n\nvbin16 = size octets size = uint16 octets = 0*65535 OCTET ; size\nOCTETs'
p1460
sg5
S'vbin16'
p1461
stp1462
a(S'Str16Latin'
(g1346
t(dp1463
g4
I148
sg34
S'The str16-latin type encodes up to 65535 octets of is-8859-15\ncharacters. The number of octets is first encoded as a 16-bit unsigned\nintegral value in network byte order. This is followed by the actual\ncharacters.\n\n2 OCTETs size OCTETs +----------+------------------------+ | size |\ncharacters | +----------+------------------------+ uint16 iso-8859-15\ncharacters\n\nstr16-latin = size characters size = uint16 characters = 0*65535 OCTET\n; size OCTETs'
p1464
sg5
S'str16_latin'
p1465
stp1466
a(S'Str16'
(g1346
t(dp1467
g4
I149
sg34
S'The str16 type encodes up to 65535 octets worth of UTF-8 unicode. The\nnumber of octets is first encoded as a 16-bit unsigned integral value\nin network byte order. This is followed by the actual UTF-8 unicode.\nNote that the encoded size refers to the number of octets of unicode,\nnot necessarily the number of unicode characters since the UTF-8\nunicode may include multi-byte character sequences.\n\n2 OCTETs size OCTETs +----------+--------------+ | size | utf8-unicode\n| +----------+--------------+ uint16\n\nstr16 = size utf8-unicode size = uint16 utf8-unicode = 0*65535 OCTET ;\nsize OCTETs'
p1468
sg5
S'str16'
p1469
stp1470
a(S'Str16Utf16'
(g1346
t(dp1471
g4
I150
sg34
S'The str16-utf16 type encodes up to 65535 octets worth of UTF-16\nunicode. The number of octets is first encoded as a 16-bit unsigned\nintegral value in network byte order. This is followed by the actual\nUTF-16 unicode. Note that the encoded size refers to the number of\noctets of unicode, not the number of unicode characters since the\nUTF-16 unicode will include at least two octets per unicode character.\n\n2 OCTETs size OCTETs +----------+---------------+ | size |\nutf16-unicode | +----------+---------------+ uint16\n\nstr16-utf16 = size utf16-unicode size = uint16 utf16-unicode = 0*65535\nOCTET ; size OCTETs'
p1472
sg5
S'str16_utf16'
p1473
stp1474
a(S'ByteRanges'
(g1346
t(dp1475
g4
Nsg34
S'The byte-ranges type encodes up to 65535 octets worth of non-\noverlapping, non-touching, ascending byte ranges within a 64-bit\nsequence of bytes. Each range is represented as an inclusive lower and\nupper bound that identifies all the byte offsets included within a\ngiven range.\n\nThe number of octets of data is first encoded as a 16-bit unsigned\nintegral value in network byte order. This is then followed by the\nencoded representation of the ranges included in the set. These MUST\nbe encoded in ascending order, and any two ranges included in a given\nset MUST NOT include overlapping or touching byte offsets.\n\nEach range is encoded as a pair of 64-bit unsigned integral values in\nnetwork byte order respectively representing the lower and upper\nbounds for that range. Note that because each range is exactly 16\noctets, the size in octets of the encoded ranges will always be 16\ntimes the number of ranges in the set.\n\n+----= size OCTETs =----+ | | 2 OCTETs | 16 OCTETs |\n+----------+-----+-----------+-----+ | size | .../| range |\\... |\n+----------+---/ +-----------+ \\---+ uint16 / / \\ \\ / / \\ \\ / 8 OCTETs\n8 OCTETs \\ +-----------+-----------+ | lower | upper |\n+-----------+-----------+ uint64 uint64\n\nbyte-ranges = size *range size = uint16 range = lower upper lower =\nuint64 upper = uint64'
p1476
sg5
S'byte_ranges'
p1477
stp1478
a(S'SequenceSet'
(g1346
t(dp1479
g4
Nsg34
S'The sequence-set type is a set of pairs of RFC-1982 numbers\nrepresenting a discontinuous range within an RFC-1982 sequence. Each\npair represents a closed interval within the list.\n\nSequence-sets can be represented as lists of pairs of positive 32-bit\nnumbers, each pair representing a closed interval that does not\noverlap or touch with any other interval in the list. For example, a\nset containing words 0, 1, 2, 5, 6, and 15 can be represented:\n\n[(0, 2), (5, 6), (15, 15)]\n\n1) The list-of-pairs representation is sorted ascending (as defined by\nRFC 1982 (http://www.ietf.org/rfc/rfc1982.txt) ) by the first elements\nof each pair.\n\n2) The list-of-pairs is flattened into a list-of-words.\n\n3) Each word in the list is packed into ascending locations in memory\nwith network byte ordering.\n\n4) The size in bytes, represented as a 16-bit network-byte-order\nunsigned value, is prepended.\n\nFor instance, the example from above would be encoded:\n\n[(0, 2), (5, 6), (15, 15)] -- already sorted. [0, 2, 5, 6, 15, 15] --\nflattened. 000000000000000200000005000000060000000F0000000F -- bytes\nin hex 0018000000000000000200000005000000060000000F0000000F -- bytes\nin hex, length (24) prepended\n\n+----= size OCTETs =----+ | | 2 OCTETs | 8 OCTETs |\n+----------+-----+-----------+-----+ | size | .../| range |\\... |\n+----------+---/ +-----------+ \\---+ uint16 / / \\ \\ / / \\ \\ / / \\ \\ /\n/ \\ \\ / 4 OCTETs 4 OCTETs \\ +-------------+-------------+ | lower |\nupper | +-------------+-------------+ sequence-no sequence-no\n\nsequence-set = size *range size = uint16 ; length of variable portion\nin bytes range = lower upper ; inclusive lower = sequence-no upper =\nsequence-no'
p1480
sg5
S'sequence_set'
p1481
stp1482
a(S'Vbin32'
(g1346
t(dp1483
g4
I160
sg34
S'The vbin32 type encodes up to 4294967295 octets of opaque binary data.\nThe number of octets is first encoded as a 32-bit unsigned integral\nvalue in network byte order. This is followed by the actual data.\n\n4 OCTETs size OCTETs +----------+-------------+ | size | octets |\n+----------+-------------+ uint32\n\nvbin32 = size octets size = uint32 octets = 0*4294967295 OCTET ; size\nOCTETs'
p1484
sg5
S'vbin32'
p1485
stp1486
a(S'Map'
(g1346
t(dp1487
g4
I168
sg34
S'A map is a set of distinct keys where each key has an associated\n(type,value) pair. The triple of the key, type, and value, form an\nentry within a map. Each entry within a given map MUST have a distinct\nkey. A map is encoded as a size in octets, a count of the number of\nentries, followed by the encoded entries themselves.\n\nAn encoded map may contain up to (4294967295 - 4) octets worth of\nencoded entries. The size is encoded as a 32-bit unsigned integral\nvalue in network byte order equal to the number of octets worth of\nencoded entries plus 4. (The extra 4 octets is added for the entry\ncount.) The size is then followed by the number of entries encoded as\na 32-bit unsigned integral value in network byte order. Finally the\nentries are encoded sequentially.\n\nAn entry is encoded as the key, followed by the type, and then the\nvalue. The key is always a string encoded as a str8. The type is a\nsingle octet that may contain any valid AMQP type code. The value is\nencoded according to the rules defined by the type code for that\nentry.\n\n+------------= size OCTETs =-----------+ | | 4 OCTETs | 4 OCTETs |\n+----------+----------+-----+---------------+-----+ | size | count |\n.../| entry |\\... | +----------+----------+---/ +---------------+\n\\---+ uint32 uint32 / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / / \\ \\ / k OCTETs\n1 OCTET n OCTETs \\ +-----------+---------+-----------+ | key | type |\nvalue | +-----------+---------+-----------+ str8 *type*\n\nmap = size count *entry size = uint32 ; size of count and entries in\noctets count = uint32 ; number of entries in the map entry = key type\nvalue key = str8 type = OCTET ; type code of the value value = *OCTET\n; the encoded value'
p1488
sg5
S'map'
p1489
stp1490
a(S'List'
(g1346
t(dp1491
g4
I169
sg34
S'A list is an ordered sequence of (type, value) pairs. The (type,\nvalue) pair forms an item within the list. The list may contain items\nof many distinct types. A list is encoded as a size in octets,\nfollowed by a count of the number of items, followed by the items\nthemselves encoded in their defined order.\n\nAn encoded list may contain up to (4294967295 - 4) octets worth of\nencoded items. The size is encoded as a 32-bit unsigned integral value\nin network byte order equal to the number of octets worth of encoded\nitems plus 4. (The extra 4 octets is added for the item count.) The\nsize is then followed by the number of items encoded as a 32-bit\nunsigned integral value in network byte order. Finally the items are\nencoded sequentially in their defined order.\n\nAn item is encoded as the type followed by the value. The type is a\nsingle octet that may contain any valid AMQP type code. The value is\nencoded according to the rules defined by the type code for that item.\n\n+---------= size OCTETs =---------+ | | 4 OCTETs | 4 OCTETs |\n+----------+----------+-----+----------+-----+ | size | count | .../|\nitem |\\... | +----------+----------+---/ +----------+ \\---+ uint32\nuint32 / / \\ \\ / / \\ \\ / 1 OCTET n OCTETs \\ +----------+-----------+ |\ntype | value | +----------+-----------+ *type*\n\nlist = size count *item size = uint32 ; size of count and items in\noctets count = uint32 ; number of items in the list item = type value\ntype = OCTET ; type code of the value value = *OCTET ; the encoded\nvalue'
p1492
sg5
S'list'
p1493
stp1494
a(S'Array'
(g1346
t(dp1495
g4
I170
sg34
S'An array is an ordered sequence of values of the same type. The array\nis encoded in as a size in octets, followed by a type code, then a\ncount of the number values in the array, and finally the values\nencoded in their defined order.\n\nAn encoded array may contain up to (4294967295 - 5) octets worth of\nencoded values. The size is encoded as a 32-bit unsigned integral\nvalue in network byte order equal to the number of octets worth of\nencoded values plus 5. (The extra 5 octets consist of 4 octets for the\ncount of the number of values, and one octet to hold the type code for\nthe items in the array.) The size is then followed by a single octet\nthat may contain any valid AMQP type code. The type code is then\nfollowed by the number of values encoded as a 32-bit unsigned integral\nvalue in network byte order. Finally the values are encoded\nsequentially in their defined order according to the rules defined by\nthe type code for the array.\n\n4 OCTETs 1 OCTET 4 OCTETs (size - 5) OCTETs\n+----------+---------+----------+-------------------------+ | size |\ntype | count | values |\n+----------+---------+----------+-------------------------+ uint32\nuint32 *count* encoded *types*\n\narray = size type count values size = uint32 ; size of type, count,\nand values in octets type = OCTET ; the type of the encoded values\ncount = uint32 ; number of items in the array values = 0*4294967290\nOCTET ; (size - 5) OCTETs'
p1496
sg5
S'array'
p1497
stp1498
a(S'Struct32'
(g1346
t(dp1499
g4
I171
sg34
S'The struct32 type describes any coded struct with a 32-bit (4 octet)\nsize. The type is restricted to be only coded structs with a 32-bit\nsize, consequently the first six octets of any encoded value for this\ntype MUST always contain the size, class-code, and struct-code in that\norder.\n\nThe size is encoded as a 32-bit unsigned integral value in network\nbyte order that is equal to the size of the encoded field-data,\npacking-flags, class-code, and struct-code. The class-code is a single\noctet that may be set to any valid class code. The struct-code is a\nsingle octet that may be set to any valid struct code within the given\nclass-code.\n\nThe first six octets are then followed by the packing flags and\nencoded field data. The presence and quantity of packing-flags, as\nwell as the specific fields are determined by the struct definition\nidentified with the encoded class-code and struct-code.\n\n4 OCTETs 1 OCTET 1 OCTET pack-width OCTETs n OCTETs +----------+------\n------+-------------+-------------------+------------+ | size | class-\ncode | struct-code | packing-flags | field-data | +----------+--------\n----+-------------+-------------------+------------+ uint32 n = (size\n- 2 - pack-width)\n\nstruct32 = size class-code struct-code packing-flags field-data size =\nuint32 class-code = OCTET ; zero for top-level structs struct-code =\nOCTET ; together with class-code identifies the struct ; definition\nwhich determines the pack-width and ; fields packing-flags = 0*4 OCTET\n; pack-width OCTETs field-data = *OCTET ; (size - 2 - pack-width)\nOCTETs'
p1500
sg5
S'struct32'
p1501
stp1502
a(S'Bin40'
(g1346
t(dp1503
g4
I192
sg34
S'The bin40 type consists of five consecutive octets of opaque binary\ndata.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET 1 OCTET\n+-----------+-----------+-------------+------------+------------+ |\noctet-one | octet-two | octet-three | octet-four | octet-five |\n+-----------+-----------+-------------+------------+------------+\n\nbin40 = 5 OCTET'
p1504
sg5
S'bin40'
p1505
stp1506
a(S'Dec32'
(g1346
t(dp1507
g4
I200
sg34
S"The dec32 type is decimal value with a variable number of digits\nfollowing the decimal point. It is encoded as an 8-bit unsigned\nintegral value representing the number of decimal places. This is\nfollowed by the signed integral value encoded using a 32-bit two's\ncomplement representation in network byte order.\n\nThe former value is referred to as the exponent of the divisor. The\nlatter value is the mantissa. The decimal value is given by: mantissa\n/ 10^exponent.\n\n1 OCTET 4 OCTETs +----------+----------+ | exponent | mantissa |\n+----------+----------+ uint8 int32\n\ndec32 = exponent mantissa exponent = uint8 mantissa = int32"
p1508
sg5
S'dec32'
p1509
stp1510
a(S'Bin72'
(g1346
t(dp1511
g4
I208
sg34
S'The bin72 type consists of nine consecutive octets of opaque binary\ndata.\n\n1 OCTET 1 OCTET 1 OCTET 1 OCTET\n+-----------+-----------+-----+-------------+------------+ | octet-one\n| octet-two | ... | octet-eight | octet-nine |\n+-----------+-----------+-----+-------------+------------+\n\nbin64 = 9 OCTET'
p1512
sg5
S'bin72'
p1513
stp1514
a(S'Dec64'
(g1346
t(dp1515
g4
I216
sg34
S"The dec64 type is decimal value with a variable number of digits\nfollowing the decimal point. It is encoded as an 8-bit unsigned\nintegral value representing the number of decimal places. This is\nfollowed by the signed integral value encoded using a 64-bit two's\ncomplement representation in network byte order.\n\nThe former value is referred to as the exponent of the divisor. The\nlatter value is the mantissa. The decimal value is given by: mantissa\n/ 10^exponent.\n\n1 OCTET 8 OCTETs +----------+----------+ | exponent | mantissa |\n+----------+----------+ uint8 int64\n\ndec64 = exponent mantissa exponent = uint8 mantissa = int64"
p1516
sg5
S'dec64'
p1517
stp1518
a(S'Void'
(g1346
t(dp1519
g4
I240
sg34
S'The void type is used within tagged data structures such as maps and\nlists to indicate an empty value. The void type has no value and is\nencoded as an empty sequence of octets.'
p1520
sg5
S'void'
p1521
stp1522
a(S'Bit'
(g1346
t(dp1523
g4
I241
sg34
S'The bit type is used to indicate that a packing flag within a packed\nstruct is being used to represent a boolean value based on the\npresence of an empty value. The bit type has no value and is encoded\nas an empty sequence of octets.'
p1524
sg5
S'bit'
p1525
stp1526
a.